<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Craft TD</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #282c34;
            color: #fff;
            margin: 0;
            padding: 20px;
        }

        h1 {
            color: #61dafb;
        }

        .game-content {
            padding: 20px;
            border: 1px solid #444;
            width: 90%;
            max-width: 1200px;
            background-color: #20232a;
            border-radius: 8px;
        }

        .version-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .game-wrapper-v2 {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            gap: 20px;
            width: 100%;
            flex-wrap: wrap;
        }

        /* --- 공용 게임 스타일 --- */
        .game-container { text-align: center; }
        .game-board {
            display: grid;
            border: 2px solid #61dafb;
            background-color: #1c1e24;
            position: relative; /* 자식 요소의 absolute 포지셔닝 기준 */
            overflow: hidden; /* 게임 보드 밖으로 나가는 요소 숨기기 */
            box-shadow: 0 0 15px rgba(97, 218, 251, 0.3);
        }
        .cell {
            width: 40px;
            height: 40px;
            border: 1px solid #3a3f4a;
            box-sizing: border-box;
            transition: background-color 0.2s;
            cursor: pointer;
        }
        .start { background-color: #2E7D32; cursor: default; } /* Green */
        .end { background-color: #C62828; cursor: default; } /* Red */
        .path { background-color: rgba(255, 235, 59, 0.15); } /* Yellow transparent */
        .path-break { background-color: rgba(233, 30, 99, 0.5); } /* Pink transparent */
        
        .path-preview {
            background-color: rgba(103, 58, 183, 0.5); /* Deep Purple translucent */
            animation: blink-fade 1.2s infinite ease-in-out;
            transition: background-color 0.3s;
        }

        @keyframes blink-fade {
            0%, 100% {
                opacity: 0.4;
            }
            50% {
                opacity: 0.9;
            }
        }

        #path-arrows-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .path-arrow {
            position: absolute;
            color: rgba(255, 235, 59, 0.7);
            font-size: 24px;
            font-weight: bold;
            animation: move-arrow 1.5s linear infinite;
            will-change: transform, opacity;
        }

        @keyframes move-arrow {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) translate(0, 0) rotate(var(--rotation, 0deg));
            }
            50% {
                opacity: 1;
            }
            to {
                opacity: 0;
                transform: translate(-50%, -50%) translate(var(--translateX, 0px), var(--translateY, 0px)) rotate(var(--rotation, 0deg));
            }
        }

        /* --- 게임 전용 스타일 --- */
        .monster {
            position: absolute;
            width: 28px;
            height: 28px;
            background-color: #9C27B0;
            border-radius: 50%;
            border: 2px solid #fff;
            box-sizing: border-box;
            z-index: 10;
        }
        .monster.elite {
            background-color: #FF5722; /* Deep Orange */
            box-shadow: 0 0 8px #FF5722;
        }
        .monster.boss {
            background-color: #212121;
            border-color: #f44336;
            width: 38px;
            height: 38px;
            box-shadow: 0 0 12px #f44336;
        }
        .monster-aura {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            background-color: rgba(255, 87, 34, 0.2);
            z-index: 9;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.5; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.8; }
            100% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.5; }
        }
        .monster-hp-bar-container {
            position: absolute;
            width: 32px;
            height: 5px;
            background-color: #555;
            border-radius: 2px;
            z-index: 11;
        }
        .monster-hp-bar {
            width: 100%;
            height: 100%;
            background-color: #4CAF50;
            border-radius: 2px;
            transition: width 0.1s linear;
        }
        .monster-particle {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 2px;
            z-index: 15;
            animation: shatter 1s forwards;
            pointer-events: none;
        }

        @keyframes shatter {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }
        .tower-hp-bar-container {
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 34px;
            height: 5px;
            background-color: #555;
            border-radius: 2px;
            z-index: 2;
            display: none; /* Initially hidden */
        }
        .tower-hp-bar {
            width: 100%;
            height: 100%;
            background-color: #03A9F4; /* Blue for tower HP */
            border-radius: 2px;
            transition: width 0.1s linear;
        }
        .cooldown-progress-container {
            position: absolute;
            top: 4px;
            left: 4px;
            width: 5px;
            height: 32px;
            background-color: rgba(0,0,0,0.5);
            border-radius: 2px;
            z-index: 2;
            display: none;
        }
        .cooldown-progress-bar {
            width: 100%;
            height: 0%;
            background-color: #61dafb;
            border-radius: 2px;
            position: absolute;
            bottom: 0;
        }

        .projectile {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #FFC107;
            border-radius: 50%;
            z-index: 9;
            box-shadow: 0 0 8px #FFC107;
        }
        .projectile.missile {
            width: 12px;
            height: 12px;
            background-color: #D1C4E9;
            box-shadow: 0 0 8px #673AB7;
        }
        .laser-beam, .railgun-beam {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, rgba(255, 0, 255, 0), #f0f, #fff);
            box-shadow: 0 0 10px #f0f, 0 0 5px #fff;
            transform-origin: 0 50%;
            z-index: 9;
            pointer-events: none;
        }
        .railgun-beam {
            height: 5px;
            background: linear-gradient(90deg, rgba(97, 218, 251, 0), #61dafb, #fff);
            box-shadow: 0 0 12px #61dafb, 0 0 8px #fff;
        }

        .explosion {
            position: absolute;
            border-radius: 50%;
            background-color: orange;
            animation: explode 0.3s forwards;
            z-index: 12;
        }
        @keyframes explode {
            from { transform: scale(0.1); opacity: 1; }
            to { transform: scale(1); opacity: 0; }
        }

        .placement-menu {
            position: absolute;
            display: none;
            background-color: #282c34;
            border: 1px solid #61dafb;
            border-radius: 6px;
            z-index: 100;
            padding: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            min-width: 180px;
        }
        .placement-menu button {
            display: block; width: 100%; background-color: #444; color: white; border: none; padding: 8px 12px; margin-top: 5px; border-radius: 4px; cursor: pointer; text-align: left; font-size: 14px;
        }
        .placement-menu button:hover { background-color: #555; }
        .placement-menu button span { float: right; color: #FFEB3B; }
        .placement-menu button:disabled {
            background-color: #333;
            color: #777;
            cursor: not-allowed;
        }
        .placement-menu button:disabled span {
            color: #777;
        }
        .upgrade-info {
            font-size: 14px;
            padding-bottom: 5px;
            margin-bottom: 5px;
            border-bottom: 1px solid #444;
        }
        .upgrade-info strong {
            color: #61dafb;
            font-size: 16px;
        }

        .ui-panel {
            width: 220px;
            padding: 15px;
            background-color: #20232a;
            border-radius: 8px;
            border: 1px solid #444;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        .ui-panel h2 { margin-top: 0; color: #61dafb; border-bottom: 1px solid #444; padding-bottom: 10px; }
        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
            font-size: 20px;
            font-weight: bold;
        }
        .status-grid div {
            background-color: #282c34;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .status-grid span { display: block; font-size: 24px; }
        .energy-display { color: #FFEB3B; }
        .lives-display { color: #F44336; }
        .wave-display { color: #03A9F4; }
        .score-display { color: #4CAF50; }
        .cell-v2 {
            display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: bold; color: white; position: relative;
        }
        .cell-v2.buffed {
             box-shadow: 0 0 15px rgba(76, 175, 80, 1), inset 0 0 8px rgba(76, 175, 80, 0.8);
        }

        .tower-range-indicator {
            position: absolute;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            box-sizing: border-box;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .cell-v2:hover .tower-range-indicator {
            opacity: 1;
        }
        .tower-range-indicator.preview {
            opacity: 1;
        }
        .tower-symbol {
            position: relative;
            z-index: 1;
            pointer-events: none;
        }
        .tower-level {
            position: absolute;
            top: 1px;
            right: 3px;
            font-size: 11px;
            font-weight: bold;
            color: #FFEB3B;
            z-index: 3;
            text-shadow: 1px 1px 1px #000;
        }
        .wall-v2 { background-color: #795548; }
        .cannon-v2 { background-color: #FF9800; }
        .missile-v2 { background-color: #673AB7; }
        .laser-v2 { background-color: #E91E63; }
        .buff-v2 { background-color: #009688; }
        .railgun-v2 { background-color: #607D8B; } /* Blue Grey */
        
        .top-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        .top-controls button {
            background-color: #61dafb; color: #20232a; border: none; padding: 10px; font-size: 16px; font-weight: bold; border-radius: 5px; cursor: pointer; transition: background-color 0.2s;
        }
        .top-controls button:hover { background-color: #88eaff; }
        .top-controls button:disabled { background-color: #555; color: #888; cursor: not-allowed; }

        .game-controls { margin-top: 15px; }

        .global-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
            position: relative;
        }
        .global-actions button {
            background-color: #4CAF50;
            padding: 8px;
            font-size: 12px;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .global-actions button:disabled {
             background-color: #555; color: #888; cursor: not-allowed; 
        }

        .game-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: none;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 300;
            font-size: 14px;
        }
        .game-overlay > div {
            background-color: #282c34;
            padding: 20px 40px;
            border-radius: 8px;
            border: 1px solid #61dafb;
            box-shadow: 0 5px 25px rgba(0,0,0,0.5);
        }
        .game-overlay h2 { font-size: 48px; margin-bottom: 20px; color: #F44336; }
        .game-overlay p { font-size: 16px; line-height: 1.6; }
        .game-overlay .stats-container {
            text-align: left;
            display: inline-block;
            background-color: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            max-width: 300px;
        }
        .game-overlay .stats-container strong {
            color: #61dafb;
            display: block;
            margin-top: 10px;
            font-size: 18px;
            text-align: center;
        }
        .restart-btn {
            background-color: #61dafb; 
            color: #20232a; 
            border: none; 
            padding: 12px 20px; 
            font-size: 18px; 
            font-weight: bold; 
            border-radius: 5px; 
            cursor: pointer; 
            transition: background-color 0.2s;
            margin-top: 20px;
            width: 100%;
        }
        .restart-btn:hover {
            background-color: #88eaff;
        }


        /* Gemini AI Feature Styles */
        .ai-strategy-panel {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #444;
        }
        .ai-strategy-panel button {
            width: 100%;
            background: linear-gradient(45deg, #61dafb, #9c27b0);
            color: white;
            font-weight: bold;
            border: none;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .ai-strategy-panel button:hover {
            transform: scale(1.05);
        }
        .ai-strategy-panel button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }
        #ai-tip-box {
            margin-top: 10px;
            padding: 12px;
            background-color: #282c34;
            border: 1px dashed #61dafb;
            border-radius: 5px;
            font-size: 14px;
            line-height: 1.5;
            min-height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #61dafb;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .info-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        .info-buttons button {
            background-color: #3a3f4a;
            border: 1px solid #555;
            color: white;
            padding: 8px;
            border-radius: 5px;
            cursor: pointer;
        }
        .info-buttons button:hover {
            background-color: #4a4f5a;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }
        .modal-content {
            background-color: #282c34;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #61dafb;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }
        .modal-close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
        }
        #info-modal-body h3 {
            color: #61dafb;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }
        #info-modal-body p {
            margin: 5px 0 15px 0;
            font-size: 14px;
            line-height: 1.6;
        }
        .notification {
            position: fixed;
            top: -100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(32, 35, 42, 0.9);
            color: #61dafb;
            padding: 15px 25px;
            border-radius: 8px;
            border: 1px solid #61dafb;
            z-index: 1000;
            font-weight: bold;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s, top 0.5s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .notification.show {
            top: 40px;
            opacity: 1;
        }
        #tooltip {
            position: absolute;
            display: none;
            background-color: #20232a;
            color: #fff;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #61dafb;
            z-index: 400;
            font-size: 12px;
            pointer-events: none;
            text-align: left;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>

    <h1>Maze Craft TD</h1>

    <div class="game-content">
        <div class="version-container">
            <p>타워를 클릭하여 업그레이드하고, AI의 조언을 받아 최적의 방어선을 구축하세요!</p>
            <div class="game-wrapper-v2">
                <div class="game-container">
                    <div id="game-board-v2" class="game-board">
                        <div id="path-arrows-container"></div>
                    </div>
                </div>
                <div class="ui-panel">
                    <div class="top-controls">
                        <button id="start-wave-btn-v2">Start Wave</button>
                        <button id="game-speed-btn">Speed: 1x</button>
                    </div>

                    <h2>플레이어 정보</h2>
                    <div class="status-grid">
                        <div id="energy-display-v2" class="energy-display">⚡<span>500</span></div>
                        <div id="lives-display-v2" class="lives-display">❤️<span>20</span></div>
                        <div id="wave-display-v2" class="wave-display">🌊<span>Wave 0</span></div>
                        <div id="score-display-v2" class="score-display">🏆<span>0</span></div>
                    </div>

                    <h2>게임 정보</h2>
                    <div class="info-buttons">
                        <button id="tower-info-btn">타워 정보</button>
                        <button id="monster-info-btn">몬스터 정보</button>
                    </div>
                    
                    <div id="wave-info-panel" style="margin-top: 20px;">
                        <h2>다음 웨이브 정보</h2>
                        <div id="wave-info-box" style="font-size: 14px; line-height: 1.6; background-color: #282c34; padding: 10px; border-radius: 5px; min-height: 50px;">
                            <!-- Monster info will be populated by JS -->
                        </div>
                    </div>

                    <div class="game-controls">
                         <div class="global-actions">
                            <button id="repair-all-btn">전체 수리</button>
                            <button id="upgrade-all-btn">전체 업그레이드</button>
                        </div>
                    </div>

                    <div class="ai-strategy-panel">
                        <h2>AI 전략 어드바이저 ✨</h2>
                        <button id="get-ai-tip-btn">전략 팁 받기</button>
                        <div id="ai-tip-box">AI가 당신의 다음 수를 분석 중입니다...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="placement-menu-v2" class="placement-menu">
        <div id="build-options">
            <button data-type="WALL">벽 (Blocker)<span>⚡20</span></button>
            <button data-type="CANNON">캐논 (Cannon)<span>⚡100</span></button>
            <button data-type="LASER">레이저 (Laser)<span>⚡150</span></button>
            <button data-type="MISSILE">미사일 (Missile)<span>⚡250</span></button>
            <button data-type="BUFF">버프 타워 (Buff)<span>⚡1000</span></button>
            <button data-type="RAILGUN">레일건 (Railgun)<span>⚡1500</span></button>
        </div>
        <div id="upgrade-options">
            <div id="upgrade-info" class="upgrade-info"></div>
            <button data-type="upgrade">업그레이드<span></span></button>
            <button data-type="repair">수리<span></span></button>
        </div>
        <div id="demolish-option">
            <button data-type="bulldoze">철거<span></span></button>
        </div>
    </div>

    <div id="info-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="modal-close-btn" class="modal-close-btn">&times;</button>
            <div id="info-modal-body"></div>
        </div>
    </div>
    
    <div id="tooltip"></div>
    <div id="notification" class="notification"></div>
    <div id="game-overlay-v2" class="game-overlay">
        <div>
            <h2>GAME OVER</h2>
            <p></p>
            <button class="restart-btn" onclick="window.location.reload()">다시 시작</button>
        </div>
    </div>

<script>
(function() {
    // --- 상수 정의 ---
    const GRID_WIDTH = 15, GRID_HEIGHT = 10, CELL_SIZE = 40;
    const START_NODE = { x: 0, y: GRID_HEIGHT - 1 };
    let END_NODE = { x: GRID_WIDTH - 1, y: 0 };
    const TOWER_TYPES = { EMPTY: 0, WALL: 1, CANNON: 2, LASER: 3, MISSILE: 4, BUFF: 5, RAILGUN: 6 };
    const MAX_TOWER_LEVEL = 5;
    const TOWER_COSTS = { 
        [TOWER_TYPES.WALL]: 20, 
        [TOWER_TYPES.CANNON]: 100,
        [TOWER_TYPES.LASER]: 150,
        [TOWER_TYPES.MISSILE]: 250,
        [TOWER_TYPES.BUFF]: 1000,
        [TOWER_TYPES.RAILGUN]: 1500
    };
    const TOWER_STYLES = { 
        [TOWER_TYPES.WALL]: 'wall-v2', 
        [TOWER_TYPES.CANNON]: 'cannon-v2',
        [TOWER_TYPES.LASER]: 'laser-v2',
        [TOWER_TYPES.MISSILE]: 'missile-v2',
        [TOWER_TYPES.BUFF]: 'buff-v2',
        [TOWER_TYPES.RAILGUN]: 'railgun-v2'
    };
    const TOWER_SYMBOLS = { 
        [TOWER_TYPES.WALL]: 'B', 
        [TOWER_TYPES.CANNON]: 'C',
        [TOWER_TYPES.LASER]: 'L',
        [TOWER_TYPES.MISSILE]: 'M',
        [TOWER_TYPES.BUFF]: 'S',
        [TOWER_TYPES.RAILGUN]: 'R'
    };
    const TOWER_SUMMARIES = {
        [TOWER_TYPES.WALL]: "경로를 막는 튼튼한 방어벽입니다.",
        [TOWER_TYPES.CANNON]: "가장 기본적인 단일 공격을 하는 만능형 타워입니다.",
        [TOWER_TYPES.LASER]: "공격 속도가 매우 빠른 단일 대상 공격 타워입니다.",
        [TOWER_TYPES.MISSILE]: "강력한 광역 폭발 공격을 하는 미사일을 발사합니다.",
        [TOWER_TYPES.BUFF]: "주변 타워의 공격력을 증폭시키는 지원 타워입니다.",
        [TOWER_TYPES.RAILGUN]: "일직선 상의 모든 적을 관통하는 강력한 공격을 합니다."
    };
    const TOWER_STATS = {
        [TOWER_TYPES.WALL]: { name: "벽", hp: 500, range: 0, damage: 0, attackSpeed: 0, damageUpgrade: 0 },
        [TOWER_TYPES.CANNON]: { name: "캐논", hp: 250, range: 1.5 * CELL_SIZE, damage: 30, attackSpeed: 1000, damageUpgrade: 15 },
        [TOWER_TYPES.LASER]: { name: "레이저", hp: 200, range: 1.5 * CELL_SIZE, damage: 15, attackSpeed: 300, damageUpgrade: 5 },
        [TOWER_TYPES.MISSILE]: { name: "미사일", hp: 300, range: 2.5 * CELL_SIZE, damage: 75, attackSpeed: 2500, aoeRadius: 1.5 * CELL_SIZE, aoeDamage: 60, damageUpgrade: 50 },
        [TOWER_TYPES.BUFF]: { name: "버프 타워", hp: 150, range: 2.5 * CELL_SIZE, damage: 0, attackSpeed: 0, damageUpgrade: 0, buffMultiplier: 1.5 },
        [TOWER_TYPES.RAILGUN]: { name: "레일건", hp: 100, range: 4.5 * CELL_SIZE, damage: 300, attackSpeed: 5000, damageUpgrade: 100 }
    };
    const MONSTER_STATS = {
        normal: { name: '일반', hp: 75, speed: 50, damage: 20, attackSpeed: 1000, livesCost: 1 },
        elite: { name: '특수', hp: 250, speed: 30, damage: 50, attackSpeed: 900, livesCost: 3, aoeAuraRange: 1.5 * CELL_SIZE, aoeAuraDamage: 10, aoeAuraSpeed: 900 },
        boss: { name: '보스', hp: 1000, speed: 15, damage: 500, attackSpeed: 1500, livesCost: 999 }
    };
    const MONSTER_STYLES = {
        normal: '',
        elite: 'elite',
        boss: 'boss'
    };
    
    // --- DOM 요소 ---
    const gameBoard = document.getElementById('game-board-v2');
    if (!gameBoard) return;
    const energyDisplay = document.getElementById('energy-display-v2').querySelector('span');
    const livesDisplay = document.getElementById('lives-display-v2').querySelector('span');
    const waveDisplay = document.getElementById('wave-display-v2').querySelector('span');
    const scoreDisplay = document.getElementById('score-display-v2').querySelector('span');
    const waveInfoBox = document.getElementById('wave-info-box');
    const placementMenu = document.getElementById('placement-menu-v2');
    const buildOptions = document.getElementById('build-options');
    const demolishOption = document.getElementById('demolish-option');
    const upgradeOptions = document.getElementById('upgrade-options');
    const upgradeInfo = document.getElementById('upgrade-info');
    const startWaveBtn = document.getElementById('start-wave-btn-v2');
    const repairAllBtn = document.getElementById('repair-all-btn');
    const upgradeAllBtn = document.getElementById('upgrade-all-btn');
    const gameSpeedBtn = document.getElementById('game-speed-btn');
    const gameOverlay = document.getElementById('game-overlay-v2');
    const getAITipBtn = document.getElementById('get-ai-tip-btn');
    const aiTipBox = document.getElementById('ai-tip-box');
    const towerInfoBtn = document.getElementById('tower-info-btn');
    const monsterInfoBtn = document.getElementById('monster-info-btn');
    const infoModal = document.getElementById('info-modal');
    const infoModalBody = document.getElementById('info-modal-body');
    const modalCloseBtn = document.getElementById('modal-close-btn');
    const notificationEl = document.getElementById('notification');
    const tooltipEl = document.getElementById('tooltip');
    const pathArrowsContainer = document.getElementById('path-arrows-container');

    // --- 게임 상태 변수 ---
    const grid = [], nodes = [], cells = [];
    let towers = [];
    let playerEnergy = 500, playerLives = 20, waveNumber = 0, playerScore = 0, monstersKilled = 0;
    let activeCell = null;
    let monsters = [], projectiles = [];
    let monsterIdCounter = 0;
    let waveInProgress = false;
    let monstersToSpawn = [];
    let lastSpawnTime = 0;
    let lastTimestamp = 0;
    let gameSpeed = 1;
    let notificationTimeout;
    let currentPathForWave = [];
    let totalEnergyEarned = 500;
    let totalRepairSpent = 0;
    let totalUpgradeSpent = 0;
    let totalDamageDealt = 0;

    function init() {
        gameBoard.style.gridTemplateColumns = `repeat(${GRID_WIDTH}, 1fr)`;
        gameBoard.style.width = `${GRID_WIDTH * CELL_SIZE}px`;
        gameBoard.style.height = `${GRID_HEIGHT * CELL_SIZE}px`;

        for (let y = 0; y < GRID_HEIGHT; y++) {
            grid[y] = []; nodes[y] = []; cells[y] = [];
            for (let x = 0; x < GRID_WIDTH; x++) {
                grid[y][x] = TOWER_TYPES.EMPTY;
                const cell = document.createElement('div');
                cell.className = 'cell cell-v2';
                cell.dataset.x = x; cell.dataset.y = y;
                if ((x === START_NODE.x && y === START_NODE.y)) {
                    cell.classList.add('start');
                } else if (x === END_NODE.x && y === END_NODE.y) {
                    cell.classList.add('end');
                }
                
                if (!cell.classList.contains('start') && !cell.classList.contains('end')) {
                    const hpContainer = document.createElement('div');
                    hpContainer.className = 'tower-hp-bar-container';
                    const hpBar = document.createElement('div');
                    hpBar.className = 'tower-hp-bar';
                    hpContainer.appendChild(hpBar);
                    cell.appendChild(hpContainer);
                }
                const rangeIndicator = document.createElement('div');
                rangeIndicator.className = 'tower-range-indicator';
                cell.appendChild(rangeIndicator);
                const towerSymbolSpan = document.createElement('span');
                towerSymbolSpan.className = 'tower-symbol';
                cell.appendChild(towerSymbolSpan);
                const towerLevelSpan = document.createElement('span');
                towerLevelSpan.className = 'tower-level';
                cell.appendChild(towerLevelSpan);
                const cooldownContainer = document.createElement('div');
                cooldownContainer.className = 'cooldown-progress-container';
                const cooldownBar = document.createElement('div');
                cooldownBar.className = 'cooldown-progress-bar';
                cooldownContainer.appendChild(cooldownBar);
                cell.appendChild(cooldownContainer);
                gameBoard.appendChild(cell);
                cells[y][x] = cell;
                nodes[y][x] = { x, y, g:0, h:0, f:0, parent: null };
            }
        }
        
        gameBoard.addEventListener('click', handleCellClick);
        placementMenu.addEventListener('click', handleMenuClick);
        
        buildOptions.querySelectorAll('button').forEach(button => {
            button.addEventListener('mouseenter', showPathAndRangePreview);
            button.addEventListener('mouseleave', hidePathAndRangePreview);
        });

        const demolishButton = demolishOption.querySelector('button');
        demolishButton.addEventListener('mouseenter', showDemolishPreview);
        demolishButton.addEventListener('mouseleave', hidePathAndRangePreview);

        startWaveBtn.addEventListener('click', startWave);
        
        repairAllBtn.addEventListener('click', repairAllTowers);
        repairAllBtn.addEventListener('mouseenter', showRepairTooltip);
        repairAllBtn.addEventListener('mouseleave', hideTooltip);

        upgradeAllBtn.addEventListener('click', upgradeAllTowers);
        upgradeAllBtn.addEventListener('mouseenter', showUpgradeTooltip);
        upgradeAllBtn.addEventListener('mouseleave', hideTooltip);

        gameSpeedBtn.addEventListener('click', toggleGameSpeed);
        getAITipBtn.addEventListener('click', getStrategicTip);
        towerInfoBtn.addEventListener('click', () => showInfoModal('towers'));
        monsterInfoBtn.addEventListener('click', () => showInfoModal('monsters'));
        modalCloseBtn.addEventListener('click', () => infoModal.style.display = 'none');
        infoModal.addEventListener('click', (e) => {
            if (e.target === infoModal) infoModal.style.display = 'none';
        });

        document.addEventListener('click', (e) => {
            if (!placementMenu.contains(e.target) && !e.target.closest('.cell')) {
                placementMenu.style.display = 'none';
                hidePathAndRangePreview();
            }
        });

        updateUI();
        updateWaveInfoUI();
        updateGlobalButtonsState();
        updatePathVisuals();
        requestAnimationFrame(gameLoop);
    }

    function showInfoModal(type) {
        let html = '';
        if (type === 'towers') {
            html += '<h3>타워 정보</h3>';
            Object.keys(TOWER_TYPES).forEach(key => {
                if (key === 'EMPTY') return;
                
                const towerTypeEnum = TOWER_TYPES[key];
                const stats = TOWER_STATS[towerTypeEnum];
                const cost = TOWER_COSTS[towerTypeEnum];
                const symbol = TOWER_SYMBOLS[towerTypeEnum];
                const summary = TOWER_SUMMARIES[towerTypeEnum];
                
                if (stats) {
                    html += `<h4>${stats.name} (${symbol})</h4>`;
                    if (summary) {
                        html += `<p style="font-style: italic; color: #ccc; margin-top: -10px;">${summary}</p>`;
                    }
                    let desc = `<p>비용: ⚡${cost || 0} | HP: ${stats.hp}<br>`;
                    if (stats.damage > 0) desc += `데미지: ${stats.damage}<br>`;
                    if (stats.buffMultiplier > 0) desc += `데미지 버프: x${stats.buffMultiplier}<br>`;
                    if (stats.range > 0) desc += `사거리: ${stats.range / CELL_SIZE}칸<br>`;
                    if (stats.attackSpeed > 0) desc += `공격 속도: ${stats.attackSpeed / 1000}초<br>`;
                    if (stats.aoeRadius > 0) desc += `광역 데미지: ${stats.aoeDamage} (반경: ${stats.aoeRadius / CELL_SIZE}칸)<br>`;
                    if (key === 'WALL') desc += `경로를 막지 않으며, 몬스터는 벽을 공격해서 파괴하고 지나갑니다.<br>`;
                    desc += `</p>`;
                    html += desc;
                }
            });
        } else if (type === 'monsters') {
            html += '<h3>몬스터 정보 (다음 웨이브 기준)</h3>';
            const nextWaveNum = waveNumber < 1 ? 1 : waveNumber + 1;
            const hpMultiplier = Math.pow(1.2, nextWaveNum - 1);
            Object.values(MONSTER_STATS).forEach(stats => {
                html += `<h4>${stats.name}</h4>`;
                let infoText = `<p>HP: ${Math.floor(stats.hp * hpMultiplier)}<br>이동 속도: ${stats.speed}<br>공격력: ${stats.damage}<br>공격 속도: ${stats.attackSpeed/1000}초<br>`;
                if (stats.aoeAuraDamage) {
                    infoText += `광역 데미지: ${stats.aoeAuraDamage}<br>`;
                }
                infoText += `생명력 피해: ${stats.livesCost}</p>`;
                html += infoText;
            });
        }
        infoModalBody.innerHTML = html;
        infoModal.style.display = 'flex';
    }

    async function getStrategicTip() {
        getAITipBtn.disabled = true;
        aiTipBox.innerHTML = '<div class="loader"></div>';
        let gridRepresentation = '';
        for (let y = 0; y < GRID_HEIGHT; y++) {
            let row = '';
            for (let x = 0; x < GRID_WIDTH; x++) {
                if (x === START_NODE.x && y === START_NODE.y) row += 'S ';
                else if (x === END_NODE.x && y === END_NODE.y) row += 'G ';
                else {
                    const towerType = grid[y][x];
                    if (towerType === TOWER_TYPES.EMPTY) row += '· ';
                    else row += (TOWER_SYMBOLS[towerType] || 'T') + ' ';
                }
            }
            gridRepresentation += row.trim() + '\n';
        }
        const towerList = towers.map(t => `- ${TOWER_SYMBOLS[t.type]} at (${t.x}, ${t.y}) with ${t.hp}/${t.maxHp} HP`).join('\n') || 'None';
        const systemPrompt = `You are an expert strategist for a tower defense game called 'Maze Craft TD'. Your goal is to provide a clear, concise, and actionable tip in Korean to the player based on their current game state. The player is trying to prevent monsters from reaching the Goal (G) from the Start (S). Analyze the map layout, tower positions, and player resources. Monsters will attack and destroy towers if their path is blocked. Provide one helpful tip in 2-3 sentences. Focus on improving tower placement, energy management, creating mazes, or preparing for the next wave. The grid symbols mean: S=Start, G=Goal, ·=Empty/Path, B=Wall, C=Cannon, L=Laser, M=Missile.`;
        const userQuery = `Current Game State:\n- Grid Size: ${GRID_WIDTH}x${GRID_HEIGHT}\n- Player Energy: ${playerEnergy}\n- Player Lives: ${playerLives}\n- Current Wave: ${waveNumber}\n- Towers:\n${towerList}\n- Map Layout:\n${gridRepresentation}\nPlease provide a strategic tip in Korean.`;
        try {
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error(`API call failed with status: ${response.status}`);
            const result = await response.json();
            const tip = result.candidates?.[0]?.content?.parts?.[0]?.text;
            aiTipBox.innerText = tip || "팁을 생성하는 데 실패했습니다. 다시 시도해 주세요.";
        } catch (error) {
            console.error("Error fetching AI tip:", error);
            aiTipBox.innerText = "오류가 발생했습니다. 잠시 후 다시 시도해 주세요.";
        } finally {
            getAITipBtn.disabled = false;
        }
    }

    function handleCellClick(e) {
        const cell = e.target.closest('.cell');
        if (!cell || cell.classList.contains('start') || cell.classList.contains('end')) return;

        const x = parseInt(cell.dataset.x), y = parseInt(cell.dataset.y);
        const existingTowerType = grid[y][x];

        if (existingTowerType === TOWER_TYPES.EMPTY && waveInProgress) {
            return;
        }

        activeCell = cell;
        const rect = cell.getBoundingClientRect();
        placementMenu.style.top = `${window.scrollY + rect.bottom}px`;
        placementMenu.style.left = `${window.scrollX + rect.left}px`;
        
        buildOptions.style.display = 'none';
        upgradeOptions.style.display = 'none';
        demolishOption.style.display = 'none';

        if (existingTowerType === TOWER_TYPES.EMPTY) {
            buildOptions.style.display = 'block';
            buildOptions.querySelectorAll('button').forEach(button => {
                const towerType = TOWER_TYPES[button.dataset.type];
                button.disabled = playerEnergy < TOWER_COSTS[towerType] || waveInProgress;
            });
        } else {
            const tower = towers.find(t => t.x === x && t.y === y);
            if (!tower) return; 

            demolishOption.style.display = 'block';
            const refund = Math.floor((TOWER_COSTS[existingTowerType] + tower.totalUpgradeCost) * 0.7);
            demolishOption.querySelector('span').textContent = `+⚡${refund}`;
            demolishOption.querySelector('button').disabled = waveInProgress;

            upgradeOptions.style.display = 'block';

            const repairBtn = upgradeOptions.querySelector('button[data-type="repair"]');
            
            const lostHpRatio = (tower.maxHp > 0) ? (tower.maxHp - tower.hp) / tower.maxHp : 0;
            const totalInvested = TOWER_COSTS[tower.type] + tower.totalUpgradeCost;
            const repairCost = Math.ceil(totalInvested * lostHpRatio);

            if (repairCost > 0) {
                repairBtn.style.display = 'block';
                repairBtn.disabled = playerEnergy < repairCost || waveInProgress;
                repairBtn.querySelector('span').textContent = `⚡${repairCost}`;
            } else {
                repairBtn.style.display = 'none';
            }

            const upgradeBtn = upgradeOptions.querySelector('button[data-type="upgrade"]');
            const stats = TOWER_STATS[tower.type];
            let infoText = `<strong>${stats.name} (Lv.${tower.level})</strong><br>HP: ${Math.floor(tower.hp)} / ${tower.maxHp}`;

            if(tower.type !== TOWER_TYPES.WALL) {
                upgradeBtn.style.display = 'block';
                const upgradeCost = Math.floor((TOWER_COSTS[tower.type] + tower.totalUpgradeCost) * 0.5);
                
                const hpIncrease = Math.floor(TOWER_STATS[tower.type].hp * 0.2);
                infoText += ` → ${Math.floor(tower.maxHp + hpIncrease)}`;

                if (stats.damageUpgrade > 0) {
                    const currentEffectiveDamage = getTowerEffectiveDamage(tower);
                    const nextLevelBaseDamage = tower.damage + stats.damageUpgrade;
                    const nextLevelEffectiveDamage = getTowerEffectiveDamage({ ...tower, damage: nextLevelBaseDamage });
                    
                    let damageText;
                    if (currentEffectiveDamage > tower.damage) {
                        damageText = `${tower.damage} <span style="color:#4CAF50;">(+${Math.round(currentEffectiveDamage - tower.damage)})</span>`;
                    } else {
                        damageText = tower.damage;
                    }
                    
                    let nextDamageText;
                    if (nextLevelEffectiveDamage > nextLevelBaseDamage) {
                        nextDamageText = `${nextLevelBaseDamage} <span style="color:#4CAF50;">(+${Math.round(nextLevelEffectiveDamage - nextLevelBaseDamage)})</span>`;
                    } else {
                        nextDamageText = nextLevelBaseDamage;
                    }

                    let upgradeText = `<br>데미지: ${damageText} → ${nextDamageText}`;
                    if (tower.type === TOWER_TYPES.RAILGUN) {
                         upgradeText += `<br>공격 속도: ${(tower.attackSpeed / 1000).toFixed(1)}s → ${( (tower.attackSpeed - 300) / 1000).toFixed(1)}s`;
                    } else if (tower.type === TOWER_TYPES.MISSILE) {
                        upgradeText += `<br>공격 속도: ${(tower.attackSpeed / 1000).toFixed(1)}s → ${( (tower.attackSpeed - 100) / 1000).toFixed(1)}s`;
                    }
                    infoText += upgradeText;
                }
                infoText += `<br>처치 수: ${tower.killCount || 0}`;

                const upgradeBtnSpan = upgradeBtn.querySelector('span');

                if (tower.level >= MAX_TOWER_LEVEL) {
                    upgradeBtn.disabled = true;
                    upgradeBtnSpan.textContent = `MAX`;
                } else {
                    upgradeBtn.disabled = playerEnergy < upgradeCost || waveInProgress;
                    upgradeBtnSpan.textContent = `⚡${upgradeCost}`;
                }
            } else {
                upgradeBtn.style.display = 'none';
                infoText += `<br>업그레이드 불가`;
            }
            upgradeInfo.innerHTML = infoText;
        }
        
        placementMenu.style.display = 'block';
    }

    function handleMenuClick(e) {
        if (!activeCell || !e.target.closest('button')) return;
        const x = parseInt(activeCell.dataset.x), y = parseInt(activeCell.dataset.y);
        const action = e.target.closest('button').dataset.type;

        if (action === 'bulldoze') {
            const existingTower = towers.find(t => t.x === x && t.y === y);
            if(existingTower) {
                const refund = Math.floor((TOWER_COSTS[existingTower.type] + existingTower.totalUpgradeCost) * 0.7);
                playerEnergy += refund;
                removeTower(existingTower);
            }
        } else if (action === 'upgrade') {
            const tower = towers.find(t => t.x === x && t.y === y);
            if(tower && tower.level < MAX_TOWER_LEVEL) {
                const upgradeCost = Math.floor((TOWER_COSTS[tower.type] + tower.totalUpgradeCost) * 0.5);
                if(playerEnergy >= upgradeCost) {
                    playerEnergy -= upgradeCost;
                    totalUpgradeSpent += upgradeCost;
                    tower.totalUpgradeCost += upgradeCost;
                    tower.level++;
                    
                    if (TOWER_STATS[tower.type].damageUpgrade > 0) {
                        tower.damage += TOWER_STATS[tower.type].damageUpgrade;
                    }
                    
                    const hpIncrease = Math.floor(TOWER_STATS[tower.type].hp * 0.2);
                    tower.maxHp += hpIncrease;
                    tower.hp += hpIncrease;
                    updateTowerHPBar(tower);

                    if (tower.type === TOWER_TYPES.MISSILE) {
                        tower.aoeDamage += Math.floor(TOWER_STATS[tower.type].aoeDamage * 0.2);
                        tower.attackSpeed -= 100;
                    } else if (tower.type === TOWER_TYPES.RAILGUN) {
                        tower.attackSpeed -= 300;
                    }
                    cells[y][x].querySelector('.tower-level').textContent = `L${tower.level}`;
                }
            }
        } else if (action === 'repair') {
            const tower = towers.find(t => t.x === x && t.y === y);
            if (tower) {
                const lostHpRatio = (tower.maxHp > 0) ? (tower.maxHp - tower.hp) / tower.maxHp : 0;
                const totalInvested = TOWER_COSTS[tower.type] + tower.totalUpgradeCost;
                const repairCost = Math.ceil(totalInvested * lostHpRatio);

                if (playerEnergy >= repairCost) {
                    playerEnergy -= repairCost;
                    totalRepairSpent += repairCost;
                    tower.hp = tower.maxHp;
                    updateTowerHPBar(tower);
                }
            }
        }
        else { // Build tower
            const towerType = TOWER_TYPES[action];
            if (playerEnergy >= TOWER_COSTS[towerType]) {
                playerEnergy -= TOWER_COSTS[towerType];
                addTower(x, y, towerType);
            }
        }
        placementMenu.style.display = 'none';
        updateUI();
        updateGlobalButtonsState();
        updatePathVisuals();
    }

    function addTower(x, y, type) {
        grid[y][x] = type;
        const stats = TOWER_STATS[type];
        const newTower = {
            x, y, type,
            pixelX: x * CELL_SIZE + CELL_SIZE / 2,
            pixelY: y * CELL_SIZE + CELL_SIZE / 2,
            hp: stats.hp, maxHp: stats.hp,
            damage: stats.damage,
            attackSpeed: stats.attackSpeed,
            level: 1,
            totalUpgradeCost: 0,
            cooldown: 0,
            killCount: 0
        };
        if(type === TOWER_TYPES.MISSILE) newTower.aoeDamage = stats.aoeDamage;

        towers.push(newTower);
        
        const cell = cells[y][x];
        cell.classList.add(TOWER_STYLES[type]);
        cell.querySelector('.tower-symbol').textContent = TOWER_SYMBOLS[type];
        if (stats.range > 0) {
            cell.querySelector('.tower-range-indicator').style.width = `${stats.range * 2}px`;
            cell.querySelector('.tower-range-indicator').style.height = `${stats.range * 2}px`;
        }
        if(type !== TOWER_TYPES.WALL) {
            cell.querySelector('.tower-level').textContent = `L1`;
        }
        if (type === TOWER_TYPES.RAILGUN) {
            cell.querySelector('.cooldown-progress-container').style.display = 'block';
        }

        updateTowerHPBar(newTower);
        updateAllBuffs();
        updatePathVisuals();
    }

    function removeTower(tower) {
        const { x, y, type } = tower;
        grid[y][x] = TOWER_TYPES.EMPTY;
        
        const cell = cells[y][x];
        cell.classList.remove(TOWER_STYLES[type]);
        cell.querySelector('.tower-symbol').textContent = '';
        cell.querySelector('.tower-hp-bar-container').style.display = 'none';
        cell.querySelector('.tower-level').textContent = '';
        cell.querySelector('.cooldown-progress-container').style.display = 'none';
        
        towers = towers.filter(t => t !== tower);
        updateAllBuffs();
        updateUI();
        if (!waveInProgress) {
             updatePathVisuals();
        }
    }
    
    function fireProjectile(tower, target) {
        const effectiveDamage = getTowerEffectiveDamage(tower);
        let effectiveAoeDamage = tower.aoeDamage;
        if (getTowerBuffedStatus(tower)) {
             effectiveAoeDamage = (tower.aoeDamage || 0) * TOWER_STATS[TOWER_TYPES.BUFF].buffMultiplier;
        }
        
        const projectile = {
            sourceTower: tower,
            x: tower.pixelX, y: tower.pixelY,
            damage: effectiveDamage, target: target,
            element: document.createElement('div'), towerType: tower.type,
            aoeDamage: effectiveAoeDamage,
        };
        projectile.element.className = `projectile ${tower.type === TOWER_TYPES.MISSILE ? 'missile' : ''}`;
        gameBoard.appendChild(projectile.element);
        projectiles.push(projectile);
    }
    
    function fireLaserBeam(tower, target) {
        damageMonster(target, getTowerEffectiveDamage(tower), tower);
        const beam = document.createElement('div');
        beam.className = 'laser-beam';
        const dx = target.x - tower.pixelX, dy = target.y - tower.pixelY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
        beam.style.left = `${tower.pixelX}px`;
        beam.style.top = `${tower.pixelY - 1.5}px`;
        beam.style.width = `${distance}px`;
        beam.style.transform = `rotate(${angle}deg)`;
        gameBoard.appendChild(beam);
        setTimeout(() => beam.remove(), 100);
    }
    
    function fireRailgun(tower, target) {
        const effectiveDamage = getTowerEffectiveDamage(tower);
        const beam = document.createElement('div');
        beam.className = 'railgun-beam';
        const dx = target.x - tower.pixelX;
        const dy = target.y - tower.pixelY;
        const angleRad = Math.atan2(dy, dx);
        const angleDeg = angleRad * (180 / Math.PI);

        beam.style.left = `${tower.pixelX}px`;
        beam.style.top = `${tower.pixelY - 2.5}px`;
        beam.style.width = `${TOWER_STATS[tower.type].range}px`;
        beam.style.transform = `rotate(${angleDeg}deg)`;
        gameBoard.appendChild(beam);
        setTimeout(() => beam.remove(), 200);

        const beamVecX = Math.cos(angleRad);
        const beamVecY = Math.sin(angleRad);
        
        [...monsters].forEach(m => {
            const monsterVecX = m.x - tower.pixelX;
            const monsterVecY = m.y - tower.pixelY;

            const dotProduct = monsterVecX * beamVecX + monsterVecY * beamVecY;

            if (dotProduct > 0 && dotProduct < TOWER_STATS[tower.type].range) {
                const distToLine = Math.abs(monsterVecX * beamVecY - monsterVecY * beamVecX);
                
                if (distToLine < CELL_SIZE / 2) {
                    damageMonster(m, effectiveDamage, tower);
                }
            }
        });
    }

    function updateProjectiles(deltaTime) {
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const p = projectiles[i];
            if (!p.target || p.target.hp <= 0) {
                p.element.remove();
                projectiles.splice(i, 1);
                continue;
            }
            const dx = p.target.x - p.x, dy = p.target.y - p.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const speed = (p.towerType === TOWER_TYPES.MISSILE) ? 300 : 400;
            const moveDistance = speed * (deltaTime / 1000);

            if (distance < moveDistance) {
                damageMonster(p.target, p.damage, p.sourceTower);
                if (p.towerType === TOWER_TYPES.MISSILE) {
                    const stats = TOWER_STATS[p.towerType];
                    createExplosion(p.target.x, p.target.y, stats.aoeRadius);
                    monsters.forEach(m => {
                        if (m.hp > 0 && m !== p.target) {
                            const dist = Math.hypot(m.x - p.target.x, m.y - p.target.y);
                            if (dist < stats.aoeRadius) damageMonster(m, p.aoeDamage, p.sourceTower);
                        }
                    });
                }
                p.element.remove();
                projectiles.splice(i, 1);
            } else {
                p.x += (dx / distance) * moveDistance;
                p.y += (dy / distance) * moveDistance;
                p.element.style.left = `${p.x - 5}px`;
                p.element.style.top = `${p.y - 5}px`;
            }
        }
    }

    function createDeathEffect(monster) {
        const particleCount = 8;
        const monsterStyle = MONSTER_STYLES[monster.type];
        let monsterColor = '#9C27B0'; // default normal
        if (monsterStyle === 'elite') monsterColor = '#FF5722';
        if (monsterStyle === 'boss') monsterColor = '#212121';

        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement('div');
            particle.className = 'monster-particle';
            particle.style.backgroundColor = monsterColor;

            const angle = Math.random() * 2 * Math.PI;
            const distance = Math.random() * 40 + 20;
            const tx = `${Math.cos(angle) * distance}px`;
            const ty = `${Math.sin(angle) * distance}px`;

            particle.style.left = `${monster.x - 4}px`;
            particle.style.top = `${monster.y - 4}px`;
            particle.style.setProperty('--tx', tx);
            particle.style.setProperty('--ty', ty);
            
            gameBoard.appendChild(particle);

            setTimeout(() => {
                particle.remove();
            }, 1000);
        }
    }

    function damageMonster(monster, damage, sourceTower = null) {
        if(monster.hp <= 0) return;
        
        const damageDealt = Math.min(monster.hp, damage);
        totalDamageDealt += damageDealt;
        monster.hp -= damage;

        if (monster.hp <= 0) {
            if (sourceTower) {
                sourceTower.killCount = (sourceTower.killCount || 0) + 1;
            }
            const energyReward = 10 + (waveNumber - 1) * 3;
            playerEnergy += energyReward;
            totalEnergyEarned += energyReward;
            
            const baseScore = monster.type === 'boss' ? 500 : (monster.type === 'elite' ? 20 : 10);
            const scoreMultiplier = Math.pow(1.05, waveNumber - 1);
            playerScore += Math.floor(baseScore * scoreMultiplier);
            monstersKilled++;

            if (monster.type === 'boss') {
                playerLives = Math.min(20, playerLives + 5);
                const bossEnergyBonus = waveNumber * 100;
                playerEnergy += bossEnergyBonus;
                totalEnergyEarned += bossEnergyBonus;
                showNotification(`보스 처치! 생명력 5와 ⚡${bossEnergyBonus} 에너지를 획득했습니다.`);
            }
            createDeathEffect(monster);
            removeMonsterById(monster.id);
            updateUI();
        } else {
            updateMonsterHPBar(monster);
        }
    }
    
    function getTowerBuffedStatus(tower) {
        if(tower.type === TOWER_TYPES.WALL || tower.type === TOWER_TYPES.BUFF) return false;
        return towers.some(buffTower => 
            buffTower.type === TOWER_TYPES.BUFF &&
            Math.hypot(tower.pixelX - buffTower.pixelX, tower.pixelY - buffTower.pixelY) < TOWER_STATS[TOWER_TYPES.BUFF].range
        );
    }

    function getTowerEffectiveDamage(tower) {
        let damage = tower.damage;
        if (getTowerBuffedStatus(tower)) {
            damage *= TOWER_STATS[TOWER_TYPES.BUFF].buffMultiplier;
        }
        return damage;
    }

    function updateAllBuffs() {
        const buffTowers = towers.filter(t => t.type === TOWER_TYPES.BUFF);
        const buffedCells = new Set();

        if (buffTowers.length > 0) {
            towers.forEach(t => {
                if (t.type === TOWER_TYPES.BUFF || t.type === TOWER_TYPES.WALL) return;
                
                const isBuffed = buffTowers.some(buffTower => 
                    Math.hypot(t.pixelX - buffTower.pixelX, t.pixelY - buffTower.pixelY) < TOWER_STATS[TOWER_TYPES.BUFF].range
                );

                if (isBuffed) {
                    buffedCells.add(cells[t.y][t.x]);
                }
            });
        }
        
        for (let y = 0; y < GRID_HEIGHT; y++) {
            for (let x = 0; x < GRID_WIDTH; x++) {
                const cell = cells[y][x];
                if (buffedCells.has(cell)) {
                    cell.classList.add('buffed');
                } else {
                    cell.classList.remove('buffed');
                }
            }
        }
    }

    function generateWave(waveNum) {
        const hpMultiplier = Math.pow(1.2, waveNum - 1);
        let waveConfig = {};

        if (waveNum > 0 && waveNum % 10 === 0) {
            const bossHpMultiplier = 1 + (waveNum - 10) / 15; // 보스 체력 상승 완화
            waveConfig = {
                 monsters: [{ type: 'boss', count: 1, hpMultiplier: hpMultiplier * bossHpMultiplier }]
            };
        } else {
            const monsterCount = 10 + Math.floor(Math.pow(waveNum, 1.15));
            waveConfig = {
                monsters: [{ type: 'normal', count: monsterCount, hpMultiplier: hpMultiplier }]
            };

            if (waveNum > 0 && waveNum % 5 === 0) {
                const eliteCount = Math.floor(waveNum / 5);
                waveConfig.monsters.push({ type: 'elite', count: eliteCount, hpMultiplier: hpMultiplier });
            }
        }
        return waveConfig;
    }

    function gameLoop(timestamp) {
        const deltaTime = (timestamp - lastTimestamp) || 0;
        lastTimestamp = timestamp;

        const effectiveDeltaTime = deltaTime * gameSpeed;

        if (playerLives > 0) {
            if (waveInProgress) spawnMonsters(timestamp);
            updateTowers(effectiveDeltaTime);
            updateMonsters(effectiveDeltaTime);
            updateProjectiles(effectiveDeltaTime);
        }
        requestAnimationFrame(gameLoop);
    }
    
    function updateTowers(deltaTime) {
        towers.forEach(tower => {
            if (tower.type === TOWER_TYPES.RAILGUN) {
                const cooldownBar = cells[tower.y][tower.x].querySelector('.cooldown-progress-bar');
                const progress = (tower.attackSpeed - tower.cooldown) / tower.attackSpeed;
                cooldownBar.style.height = `${Math.min(100, progress * 100)}%`;
            }

            if(TOWER_STATS[tower.type].damage === 0) return;
            tower.cooldown -= deltaTime;
            if (tower.cooldown <= 0) {
                const target = findTarget(tower);
                if (target) {
                    if (tower.type === TOWER_TYPES.LASER) fireLaserBeam(tower, target);
                    else if (tower.type === TOWER_TYPES.RAILGUN) fireRailgun(tower, target);
                    else fireProjectile(tower, target);
                    tower.cooldown = tower.attackSpeed;
                }
            }
        });
    }
    
    function createMonster(type, hpMultiplier = 1, path) {
        const stats = MONSTER_STATS[type];
        const monster = {
            id: monsterIdCounter++, type: type, path: path, pathIndex: 1,
            x: START_NODE.x * CELL_SIZE + CELL_SIZE / 2, y: START_NODE.y * CELL_SIZE + CELL_SIZE / 2,
            maxHp: stats.hp * hpMultiplier, hp: stats.hp * hpMultiplier,
            speed: stats.speed, damage: stats.damage, attackSpeed: stats.attackSpeed, attackCooldown: 0,
            livesCost: stats.livesCost,
            element: document.createElement('div'),
            hpBarContainer: document.createElement('div'), hpBar: document.createElement('div'),
        };
        monster.element.className = 'monster';
        if (MONSTER_STYLES[type]) {
            monster.element.classList.add(MONSTER_STYLES[type]);
        }
        if (type === 'elite') {
            monster.aoeAuraCooldown = 0;
            const aura = document.createElement('div');
            aura.className = 'monster-aura';
            aura.style.width = `${stats.aoeAuraRange * 2}px`;
            aura.style.height = `${stats.aoeAuraRange * 2}px`;
            monster.auraElement = aura;
            monster.element.appendChild(aura);
        }
        monster.hpBarContainer.className = 'monster-hp-bar-container';
        monster.hpBar.className = 'monster-hp-bar';
        monster.hpBarContainer.appendChild(monster.hpBar);
        gameBoard.appendChild(monster.element);
        gameBoard.appendChild(monster.hpBarContainer);
        monsters.push(monster);
    }
    
    function updateMonsters(deltaTime) {
        for (let i = monsters.length - 1; i >= 0; i--) {
            const monster = monsters[i];
            if (!monster.path || monster.pathIndex >= monster.path.length) {
                playerLives = Math.max(0, playerLives - monster.livesCost);
                removeMonster(monster, i);
                updateUI();
                if (playerLives <= 0) gameOver();
                continue;
            }

            // Elite monster AOE aura
            if (monster.type === 'elite') {
                monster.aoeAuraCooldown -= deltaTime;
                if(monster.aoeAuraCooldown <= 0) {
                    const stats = MONSTER_STATS.elite;
                    towers.forEach(tower => {
                        const dist = Math.hypot(monster.x - tower.pixelX, monster.y - tower.pixelY);
                        if (dist < stats.aoeAuraRange) {
                            tower.hp -= stats.aoeAuraDamage;
                            updateTowerHPBar(tower);
                            if(tower.hp <= 0) removeTower(tower);
                        }
                    });
                    monster.aoeAuraCooldown = stats.aoeAuraSpeed;
                }
            }

            const nextNode = monster.path[monster.pathIndex];
            const targetTower = towers.find(t => t.x === nextNode.x && t.y === nextNode.y);
            
            if (targetTower) { 
                monster.attackCooldown -= deltaTime;
                if (monster.attackCooldown <= 0) {
                    targetTower.hp -= monster.damage;
                    updateTowerHPBar(targetTower);
                    if (targetTower.hp <= 0) {
                        removeTower(targetTower);
                    }
                    monster.attackCooldown = monster.attackSpeed;
                }
            } else { 
                const targetX = nextNode.x * CELL_SIZE + CELL_SIZE / 2;
                const targetY = nextNode.y * CELL_SIZE + CELL_SIZE / 2;
                const dx = targetX - monster.x, dy = targetY - monster.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const moveDistance = monster.speed * (deltaTime / 1000);

                if (distance < moveDistance) {
                    monster.x = targetX;
                    monster.y = targetY;
                    monster.pathIndex++;
                } else {
                    monster.x += (dx / distance) * moveDistance;
                    monster.y += (dy / distance) * moveDistance;
                }
            }
            
            monster.element.style.left = `${monster.x - monster.element.offsetWidth / 2}px`;
            monster.element.style.top = `${monster.y - monster.element.offsetHeight / 2}px`;
            monster.hpBarContainer.style.left = `${monster.x - monster.hpBarContainer.offsetWidth / 2}px`;
            monster.hpBarContainer.style.top = `${monster.y - monster.element.offsetHeight / 2 - 7}px`;
        }
    }

    function createExplosion(x, y, radius) {
        const explosion = document.createElement('div');
        explosion.className = 'explosion';
        explosion.style.left = `${x - radius}px`;
        explosion.style.top = `${y - radius}px`;
        explosion.style.width = `${radius * 2}px`;
        explosion.style.height = `${radius * 2}px`;
        gameBoard.appendChild(explosion);
        setTimeout(() => explosion.remove(), 300);
    }
    
    function aStar(start, end, canBreakWalls) {
        const openSet = [], closedSet = new Set();
        for (let y = 0; y < GRID_HEIGHT; y++) { for (let x = 0; x < GRID_WIDTH; x++) { nodes[y][x].g=0; nodes[y][x].h=0; nodes[y][x].f=0; nodes[y][x].parent=null; } }
        openSet.push(nodes[start.y][start.x]);
        while (openSet.length > 0) {
            openSet.sort((a,b) => a.f-b.f);
            const currentNode = openSet.shift();
            if (currentNode.x === end.x && currentNode.y === end.y) { const path = []; let temp = currentNode; while (temp) { path.push(temp); temp = temp.parent; } return path.reverse(); }
            closedSet.add(currentNode);
            const neighbors = getNeighbors(currentNode);
            for (const neighbor of neighbors) {
                if (closedSet.has(neighbor)) continue;
                const towerTypeAtNeighbor = grid[neighbor.y][neighbor.x];
                const isObstacle = towerTypeAtNeighbor !== TOWER_TYPES.EMPTY && towerTypeAtNeighbor !== TOWER_TYPES.WALL;

                if (!canBreakWalls && isObstacle) continue;
                
                let cost = 1;
                if (canBreakWalls && towerTypeAtNeighbor !== TOWER_TYPES.EMPTY) {
                    const tower = towers.find(t => t.x === neighbor.x && t.y === neighbor.y);
                    cost += tower ? tower.hp / MONSTER_STATS.normal.damage : 1000;
                }
                const gScore = currentNode.g + cost;
                const inOpenSet = openSet.includes(neighbor);
                if (!inOpenSet || gScore < neighbor.g) {
                    neighbor.g = gScore;
                    neighbor.h = Math.abs(neighbor.x-end.x) + Math.abs(neighbor.y-end.y);
                    neighbor.f = neighbor.g + neighbor.h;
                    neighbor.parent = currentNode;
                    if (!inOpenSet) openSet.push(neighbor);
                }
            }
        }
        return null;
    }

    function updateTowerHPBar(tower) {
        const hpContainer = cells[tower.y][tower.x].querySelector('.tower-hp-bar-container');
        if(hpContainer) {
            hpContainer.style.display = 'block';
            hpContainer.querySelector('.tower-hp-bar').style.width = `${(tower.hp / tower.maxHp) * 100}%`;
        }
    }

    function randomizeEndPoint() {
        const emptyCells = [];
        const restrictedX = 3;
        const restrictedY = GRID_HEIGHT - 4; // 위로 3칸 (y=9, 8, 7, 6)

        for (let y = 0; y < GRID_HEIGHT; y++) {
            for (let x = 0; x < GRID_WIDTH; x++) {
                const isRestricted = x <= restrictedX && y >= restrictedY;
                if (grid[y][x] === TOWER_TYPES.EMPTY && !(x === START_NODE.x && y === START_NODE.y) && !isRestricted) {
                    emptyCells.push({x, y});
                }
            }
        }

        if (emptyCells.length > 0) {
            const oldEndCell = cells[END_NODE.y][END_NODE.x];
            oldEndCell.classList.remove('end');

            const newEndCoords = emptyCells[Math.floor(Math.random() * emptyCells.length)];
            END_NODE.x = newEndCoords.x;
            END_NODE.y = newEndCoords.y;
            
            const newEndCell = cells[END_NODE.y][END_NODE.x];
            newEndCell.classList.add('end');
        }
    }

    function spawnMonsters(timestamp) {
        if (monstersToSpawn.length > 0 && timestamp - lastSpawnTime > (500 / gameSpeed)) {
            const monsterData = monstersToSpawn.shift();
            createMonster(monsterData.type, monsterData.hpMultiplier, monsterData.path);
            lastSpawnTime = timestamp;
        }
        if (monstersToSpawn.length === 0 && monsters.length === 0 && waveInProgress) {
            waveInProgress = false;
            
            if (waveNumber >= 1) {
                randomizeEndPoint();
            }
            updateGlobalButtonsState();
            updateWaveInfoUI();
            updatePathVisuals();
        }
    }

    function updatePathVisuals() {
        gameBoard.querySelectorAll('.path, .path-break').forEach(p => p.classList.remove('path', 'path-break'));
        pathArrowsContainer.innerHTML = '';

        let path = aStar(START_NODE, END_NODE, false);
        let pathIsBreakable = false;
        if (!path) {
            path = aStar(START_NODE, END_NODE, true);
            pathIsBreakable = true;
        }

        if (path) {
            currentPathForWave = path; // Store for wave start
            for (let i = 0; i < path.length - 1; i++) {
                const prevNode = path[i];
                const currNode = path[i+1];
                const cell = cells[prevNode.y][prevNode.x];

                if (!cell.classList.contains('start') && !cell.classList.contains('end')) {
                    if (pathIsBreakable && grid[prevNode.y][prevNode.x] !== TOWER_TYPES.EMPTY) {
                        cell.classList.add('path-break');
                    } else {
                        cell.classList.add('path');
                    }
                }
                
                if (!waveInProgress) {
                    const arrow = document.createElement('div');
                    arrow.className = 'path-arrow';
                    arrow.textContent = '›';

                    const dx = currNode.x - prevNode.x;
                    const dy = currNode.y - prevNode.y;
                    
                    let rotation = 0;
                    if (dx > 0) rotation = 0;      // Right
                    else if (dx < 0) rotation = 180; // Left
                    else if (dy > 0) rotation = 90;  // Down
                    else if (dy < 0) rotation = -90; // Up

                    arrow.style.left = `${prevNode.x * CELL_SIZE + CELL_SIZE / 2}px`;
                    arrow.style.top = `${prevNode.y * CELL_SIZE + CELL_SIZE / 2}px`;
                    arrow.style.setProperty('--translateX', `${dx * CELL_SIZE}px`);
                    arrow.style.setProperty('--translateY', `${dy * CELL_SIZE}px`);
                    arrow.style.setProperty('--rotation', `${rotation}deg`);
                    arrow.style.animationDelay = `${Math.random() * -1.5}s`;
                    pathArrowsContainer.appendChild(arrow);
                }
            }
        }
    }
    
    function showDemolishPreview() {
        if (!activeCell || waveInProgress) return;

        const x = parseInt(activeCell.dataset.x);
        const y = parseInt(activeCell.dataset.y);
        const originalType = grid[y][x];

        if (originalType === TOWER_TYPES.EMPTY) return;

        // --- Path Preview ---
        grid[y][x] = TOWER_TYPES.EMPTY; // Temporarily remove tower
        let path = aStar(START_NODE, END_NODE, false);
        if (!path) {
            path = aStar(START_NODE, END_NODE, true);
        }
        grid[y][x] = originalType; // Restore tower
        
        if (path) {
            path.forEach(node => {
                const cell = cells[node.y][node.x];
                if (!cell.classList.contains('start') && !cell.classList.contains('end')) {
                    cell.classList.add('path-preview');
                }
            });
        }
    }

    function showPathAndRangePreview(e) {
        if (!activeCell || waveInProgress) return;

        const x = parseInt(activeCell.dataset.x);
        const y = parseInt(activeCell.dataset.y);

        if (grid[y][x] !== TOWER_TYPES.EMPTY) return;
        
        const towerType = TOWER_TYPES[e.target.dataset.type];
        if (!towerType) return;

        // --- Range Preview ---
        const stats = TOWER_STATS[towerType];
        if (stats.range > 0) {
            const rangeIndicator = activeCell.querySelector('.tower-range-indicator');
            rangeIndicator.style.width = `${stats.range * 2}px`;
            rangeIndicator.style.height = `${stats.range * 2}px`;
            rangeIndicator.classList.add('preview');
        }

        // --- Path Preview ---
        grid[y][x] = towerType;
        let path = aStar(START_NODE, END_NODE, false);
        if (!path) {
            path = aStar(START_NODE, END_NODE, true);
        }
        grid[y][x] = TOWER_TYPES.EMPTY;
        
        if (path) {
            path.forEach(node => {
                const cell = cells[node.y][node.x];
                if (!cell.classList.contains('start') && !cell.classList.contains('end')) {
                    cell.classList.add('path-preview');
                }
            });
        }
    }

    function hidePathAndRangePreview() {
        if (!activeCell) return;
        
        const rangeIndicator = activeCell.querySelector('.tower-range-indicator');
        if (rangeIndicator) {
             rangeIndicator.classList.remove('preview');
        }

        gameBoard.querySelectorAll('.path-preview').forEach(cell => {
            cell.classList.remove('path-preview');
        });
    }


    function updateUI() {
        energyDisplay.innerText = playerEnergy;
        livesDisplay.innerText = playerLives;
        waveDisplay.innerText = `Wave ${waveNumber}`;
        scoreDisplay.innerText = playerScore;
    }

    function updateWaveInfoUI() {
        const nextWave = generateWave(waveNumber + 1);
        let infoHtml = '';
        nextWave.monsters.forEach(group => {
            const monsterInfo = MONSTER_STATS[group.type];
            const hp = Math.floor(monsterInfo.hp * (group.hpMultiplier || 1));
            infoHtml += `<div>- ${monsterInfo.name} x${group.count} (HP: ${hp})</div>`;
        });
        waveInfoBox.innerHTML = infoHtml;
    }

    function findTarget(tower) {
        let closestMonster = null;
        let minDistance = TOWER_STATS[tower.type].range;
        monsters.forEach(monster => {
            const dist = Math.hypot(tower.pixelX - monster.x, tower.pixelY - monster.y);
            if (dist < minDistance) {
                minDistance = dist;
                closestMonster = monster;
            }
        });
        return closestMonster;
    }

    function startWave() {
        if (waveInProgress) return;
        waveInProgress = true;
        updateGlobalButtonsState();
        waveNumber++;
        updateUI();
        waveInfoBox.innerHTML = '웨이브 진행 중...';
        updatePathVisuals(); // Hides arrows
        const currentWave = generateWave(waveNumber);
        
        monstersToSpawn = [];
        currentWave.monsters.forEach(monsterGroup => {
            for (let i = 0; i < monsterGroup.count; i++) {
                monstersToSpawn.push({ 
                    type: monsterGroup.type, 
                    hpMultiplier: monsterGroup.hpMultiplier || 1,
                    path: currentPathForWave // Use the path calculated at wave start
                });
            }
        });

        if (waveNumber > 0 && waveNumber % 5 === 0) {
            for (let i = monstersToSpawn.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [monstersToSpawn[i], monstersToSpawn[j]] = [monstersToSpawn[j], monstersToSpawn[i]];
            }
        }
    }

    function repairAllTowers() {
        if (waveInProgress) return;
        
        let totalCost = 0;
        let repairedCount = 0;

        const towersToRepair = towers
            .filter(t => t.hp < t.maxHp)
            .map(t => {
                const lostHpRatio = (t.maxHp > 0) ? (t.maxHp - t.hp) / t.maxHp : 0;
                const totalInvested = TOWER_COSTS[t.type] + t.totalUpgradeCost;
                return {
                    tower: t,
                    cost: Math.ceil(totalInvested * lostHpRatio)
                };
            })
            .sort((a, b) => a.cost - b.cost);

        if (towersToRepair.length === 0) {
            updateGlobalButtonsState();
            return;
        }
    
        for (const item of towersToRepair) {
            if (playerEnergy >= item.cost) {
                playerEnergy -= item.cost;
                totalRepairSpent += item.cost;
                item.tower.hp = item.tower.maxHp;
                updateTowerHPBar(item.tower);
                totalCost += item.cost;
                repairedCount++;
            } else {
                break;
            }
        }
    
        if (repairedCount > 0) {
            updateUI();
            showNotification(`⚡${totalCost}를 소모하여 ${repairedCount}개의 타워를 수리했습니다.`);
        } else {
            showNotification(`에너지가 부족하여 타워를 수리할 수 없습니다.`);
        }
        
        updateGlobalButtonsState();
    }

    function upgradeAllTowers() {
        if (waveInProgress) return;
        
        const upgradableTowers = towers
            .filter(t => t.level < MAX_TOWER_LEVEL && t.type !== TOWER_TYPES.WALL)
            .map(t => ({
                tower: t,
                cost: Math.floor((TOWER_COSTS[t.type] + t.totalUpgradeCost) * 0.5)
            }))
            .sort((a, b) => a.cost - b.cost);
        
        let totalCost = 0;
        const upgradedCounts = {};

        for(const item of upgradableTowers) {
            if (playerEnergy >= item.cost) {
                const tower = item.tower;
                playerEnergy -= item.cost;
                totalUpgradeSpent += item.cost;
                totalCost += item.cost;
                tower.totalUpgradeCost += item.cost;
                tower.level++;
                
                if (TOWER_STATS[tower.type].damageUpgrade > 0) {
                    tower.damage += TOWER_STATS[tower.type].damageUpgrade;
                }
                
                const hpIncrease = Math.floor(TOWER_STATS[tower.type].hp * 0.2);
                tower.maxHp += hpIncrease;
                tower.hp += hpIncrease;
                updateTowerHPBar(tower);

                if (tower.type === TOWER_TYPES.MISSILE) {
                    tower.aoeDamage += Math.floor(TOWER_STATS[tower.type].aoeDamage * 0.2);
                    tower.attackSpeed -= 100;
                } else if (tower.type === TOWER_TYPES.RAILGUN) {
                    tower.attackSpeed -= 300;
                }
                cells[tower.y][tower.x].querySelector('.tower-level').textContent = `L${tower.level}`;
                
                const towerName = TOWER_STATS[tower.type].name;
                upgradedCounts[towerName] = (upgradedCounts[towerName] || 0) + 1;
            } else {
                break; 
            }
        }
        if (totalCost > 0) {
            let summary = `⚡${totalCost}를 소모하여 업그레이드 완료!<br>`;
            let totalUpgraded = 0;
            for(const name in upgradedCounts) {
                summary += `${name} ${upgradedCounts[name]}개, `;
                totalUpgraded += upgradedCounts[name];
            }
            summary = summary.slice(0, -2);
            showNotification(summary);
        }
        updateUI();
        updateGlobalButtonsState();
    }

    function toggleGameSpeed() {
        gameSpeed = gameSpeed === 1 ? 2 : 1;
        gameSpeedBtn.textContent = `Speed: ${gameSpeed}x`;
    }
    
    function updateGlobalButtonsState() {
        if (waveInProgress) {
            startWaveBtn.disabled = true;
            getAITipBtn.disabled = true;
            repairAllBtn.disabled = true;
            upgradeAllBtn.disabled = true;
            return;
        }
        startWaveBtn.disabled = false;
        getAITipBtn.disabled = false;

        const canRepair = towers.some(t => t.hp < t.maxHp);
        repairAllBtn.disabled = !canRepair;

        const canUpgrade = towers.some(t => t.level < MAX_TOWER_LEVEL && t.type !== TOWER_TYPES.WALL);
        upgradeAllBtn.disabled = !canUpgrade;
    }

    function showNotification(message) {
        clearTimeout(notificationTimeout);
        notificationEl.innerHTML = message;
        notificationEl.classList.add('show');
        notificationTimeout = setTimeout(() => {
            notificationEl.classList.remove('show');
        }, 3000);
    }

    function showRepairTooltip(event) {
        let totalRepairCost = 0;
        towers.forEach(t => {
            if (t.hp < t.maxHp) {
                const lostHpRatio = (t.maxHp > 0) ? (t.maxHp - t.hp) / t.maxHp : 0;
                const totalInvested = TOWER_COSTS[t.type] + t.totalUpgradeCost;
                totalRepairCost += Math.ceil(totalInvested * lostHpRatio);
            }
        });
        tooltipEl.innerHTML = `예상 비용: ⚡${totalRepairCost}`;
        tooltipEl.style.display = 'block';
        tooltipEl.style.left = `${event.pageX + 15}px`;
        tooltipEl.style.top = `${event.pageY + 15}px`;
    }

    function showUpgradeTooltip(event) {
        const upgradableTowers = towers
            .filter(t => t.level < MAX_TOWER_LEVEL && t.type !== TOWER_TYPES.WALL)
            .map(t => ({
                cost: Math.floor((TOWER_COSTS[t.type] + t.totalUpgradeCost) * 0.5),
                name: TOWER_STATS[t.type].name
            }));
        
        let totalCost = 0;
        const upgradeCounts = {};
        upgradableTowers.forEach(item => {
            totalCost += item.cost;
            upgradeCounts[item.name] = (upgradeCounts[item.name] || 0) + 1;
        });

        let summary = `예상 비용: ⚡${totalCost}<br>`;
        if (Object.keys(upgradeCounts).length > 0) {
            for (const name in upgradeCounts) {
                summary += `${name} ${upgradeCounts[name]}개, `;
            }
            summary = summary.slice(0, -2);
        } else {
            summary += "업그레이드 대상 없음";
        }

        tooltipEl.innerHTML = summary;
        tooltipEl.style.display = 'block';
        tooltipEl.style.left = `${event.pageX + 15}px`;
        tooltipEl.style.top = `${event.pageY + 15}px`;
    }

    function hideTooltip() {
        tooltipEl.style.display = 'none';
    }


    function removeMonster(monster, index) {
        monster.element.remove();
        monster.hpBarContainer.remove();
        monsters.splice(index, 1);
    }

    function removeMonsterById(id) {
        const index = monsters.findIndex(m => m.id === id);
        if (index !== -1) removeMonster(monsters[index], index);
    }

    function updateMonsterHPBar(monster) {
        monster.hpBar.style.width = `${(monster.hp / monster.maxHp) * 100}%`;
    }

    function getNeighbors(node) {
        const res = []; const {x, y} = node;
        if (x > 0) res.push(nodes[y][x-1]); if (x < GRID_WIDTH-1) res.push(nodes[y][x+1]);
        if (y > 0) res.push(nodes[y-1][x]); if (y < GRID_HEIGHT-1) res.push(nodes[y+1][x]);
        return res;
    }
    
    function gameOver() {
        const towerCounts = towers.reduce((acc, tower) => {
            const name = TOWER_STATS[tower.type].name;
            acc[name] = (acc[name] || 0) + 1;
            return acc;
        }, {});

        const towerCountString = Object.entries(towerCounts)
            .map(([name, count]) => `${name}: ${count}개`)
            .join('<br>');

        const gameOverContent = gameOverlay.querySelector('div');
        gameOverContent.innerHTML = `
            <h2>GAME OVER</h2>
            <p>
                최종 웨이브: ${waveNumber}<br>
                최종 점수: ${playerScore}<br>
                처치한 몬스터: ${monstersKilled}
            </p>
            <div class="stats-container">
                <strong>--- 상세 정보 ---</strong>
                획득한 총 에너지: ⚡${totalEnergyEarned}<br>
                총 업그레이드 비용: ⚡${totalUpgradeSpent}<br>
                총 수리 비용: ⚡${totalRepairSpent}<br>
                총 누적 데미지: ${Math.floor(totalDamageDealt)}<br>
                <strong>--- 건설된 타워 ---</strong>
                ${towerCountString || "없음"}
            </div>
            <button class="restart-btn" onclick="window.location.reload()">다시 시작</button>
        `;
        gameOverlay.style.display = 'flex';
    }

    init();
})();
</script>
</body>
</html>
