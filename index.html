<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Craft TD</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: #282c34;
            color: #fff;
            margin: 0;
            padding: 20px;
        }

        h1 {
            color: #61dafb;
        }

        .game-content {
            padding: 20px;
            border: 1px solid #444;
            width: 90%;
            max-width: 1200px;
            background-color: #20232a;
            border-radius: 8px;
        }

        .version-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }
        
        .game-wrapper-v2 {
            display: flex;
            align-items: flex-start;
            justify-content: center;
            gap: 20px;
            width: 100%;
            flex-wrap: wrap;
        }

        /* --- ê³µìš© ê²Œì„ ìŠ¤íƒ€ì¼ --- */
        .game-container { text-align: center; }
        .game-board {
            display: grid;
            border: 2px solid #61dafb;
            background-color: #1c1e24;
            position: relative; /* ìì‹ ìš”ì†Œì˜ absolute í¬ì§€ì…”ë‹ ê¸°ì¤€ */
            overflow: hidden; /* ê²Œì„ ë³´ë“œ ë°–ìœ¼ë¡œ ë‚˜ê°€ëŠ” ìš”ì†Œ ìˆ¨ê¸°ê¸° */
            box-shadow: 0 0 15px rgba(97, 218, 251, 0.3);
        }
        .cell {
            width: 40px;
            height: 40px;
            border: 1px solid #3a3f4a;
            box-sizing: border-box;
            transition: background-color 0.2s;
            cursor: pointer;
        }
        .start { background-color: #2E7D32; cursor: default; } /* Green */
        .end { background-color: #C62828; cursor: default; } /* Red */
        .path { background-color: rgba(255, 235, 59, 0.15); } /* Yellow transparent */
        .path-break { background-color: rgba(233, 30, 99, 0.5); } /* Pink transparent */
        
        .path-preview {
            background-color: rgba(103, 58, 183, 0.5); /* Deep Purple translucent */
            animation: blink-fade 1.2s infinite ease-in-out;
            transition: background-color 0.3s;
        }

        @keyframes blink-fade {
            0%, 100% {
                opacity: 0.4;
            }
            50% {
                opacity: 0.9;
            }
        }

        #path-arrows-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            overflow: hidden;
        }

        .path-arrow {
            position: absolute;
            color: rgba(255, 235, 59, 0.7);
            font-size: 24px;
            font-weight: bold;
            animation: move-arrow 1.5s linear infinite;
            will-change: transform, opacity;
        }

        @keyframes move-arrow {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) translate(0, 0) rotate(var(--rotation, 0deg));
            }
            50% {
                opacity: 1;
            }
            to {
                opacity: 0;
                transform: translate(-50%, -50%) translate(var(--translateX, 0px), var(--translateY, 0px)) rotate(var(--rotation, 0deg));
            }
        }

        /* --- ê²Œì„ ì „ìš© ìŠ¤íƒ€ì¼ --- */
        .monster {
            position: absolute;
            width: 28px;
            height: 28px;
            background-color: #9C27B0;
            border-radius: 50%;
            border: 2px solid #fff;
            box-sizing: border-box;
            z-index: 10;
        }
        .monster.elite {
            background-color: #FF5722; /* Deep Orange */
            box-shadow: 0 0 8px #FF5722;
        }
        .monster.boss {
            background-color: #212121;
            border-color: #f44336;
            width: 38px;
            height: 38px;
            box-shadow: 0 0 12px #f44336;
        }
        .monster-aura {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            background-color: rgba(255, 87, 34, 0.2);
            z-index: 9;
            animation: pulse 2s infinite;
        }
        @keyframes pulse {
            0% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.5; }
            50% { transform: translate(-50%, -50%) scale(1.2); opacity: 0.8; }
            100% { transform: translate(-50%, -50%) scale(0.8); opacity: 0.5; }
        }
        .monster-hp-bar-container {
            position: absolute;
            width: 32px;
            height: 5px;
            background-color: #555;
            border-radius: 2px;
            z-index: 11;
        }
        .monster-hp-bar {
            width: 100%;
            height: 100%;
            background-color: #4CAF50;
            border-radius: 2px;
            transition: width 0.1s linear;
        }
        .monster-particle {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 2px;
            z-index: 15;
            animation: shatter 1s forwards;
            pointer-events: none;
        }

        @keyframes shatter {
            0% {
                transform: translate(0, 0) scale(1);
                opacity: 1;
            }
            100% {
                transform: translate(var(--tx), var(--ty)) scale(0);
                opacity: 0;
            }
        }
        .tower-hp-bar-container {
            position: absolute;
            bottom: 2px;
            left: 50%;
            transform: translateX(-50%);
            width: 34px;
            height: 5px;
            background-color: #555;
            border-radius: 2px;
            z-index: 2;
            display: none; /* Initially hidden */
        }
        .tower-hp-bar {
            width: 100%;
            height: 100%;
            background-color: #03A9F4; /* Blue for tower HP */
            border-radius: 2px;
            transition: width 0.1s linear;
        }
        .cooldown-progress-container {
            position: absolute;
            top: 4px;
            left: 4px;
            width: 5px;
            height: 32px;
            background-color: rgba(0,0,0,0.5);
            border-radius: 2px;
            z-index: 2;
            display: none;
        }
        .cooldown-progress-bar {
            width: 100%;
            height: 0%;
            background-color: #61dafb;
            border-radius: 2px;
            position: absolute;
            bottom: 0;
        }

        .projectile {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #FFC107;
            border-radius: 50%;
            z-index: 9;
            box-shadow: 0 0 8px #FFC107;
        }
        .projectile.missile {
            width: 12px;
            height: 12px;
            background-color: #D1C4E9;
            box-shadow: 0 0 8px #673AB7;
        }
        .laser-beam, .railgun-beam {
            position: absolute;
            height: 3px;
            background: linear-gradient(90deg, rgba(255, 0, 255, 0), #f0f, #fff);
            box-shadow: 0 0 10px #f0f, 0 0 5px #fff;
            transform-origin: 0 50%;
            z-index: 9;
            pointer-events: none;
        }
        .railgun-beam {
            height: 5px;
            background: linear-gradient(90deg, rgba(97, 218, 251, 0), #61dafb, #fff);
            box-shadow: 0 0 12px #61dafb, 0 0 8px #fff;
        }

        .explosion {
            position: absolute;
            border-radius: 50%;
            background-color: orange;
            animation: explode 0.3s forwards;
            z-index: 12;
        }
        @keyframes explode {
            from { transform: scale(0.1); opacity: 1; }
            to { transform: scale(1); opacity: 0; }
        }

        .placement-menu {
            position: absolute;
            display: none;
            background-color: #282c34;
            border: 1px solid #61dafb;
            border-radius: 6px;
            z-index: 100;
            padding: 10px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
            min-width: 180px;
        }
        .placement-menu button {
            display: block; width: 100%; background-color: #444; color: white; border: none; padding: 8px 12px; margin-top: 5px; border-radius: 4px; cursor: pointer; text-align: left; font-size: 14px;
        }
        .placement-menu button:hover { background-color: #555; }
        .placement-menu button span { float: right; color: #FFEB3B; }
        .placement-menu button:disabled {
            background-color: #333;
            color: #777;
            cursor: not-allowed;
        }
        .placement-menu button:disabled span {
            color: #777;
        }
        .upgrade-info {
            font-size: 14px;
            padding-bottom: 5px;
            margin-bottom: 5px;
            border-bottom: 1px solid #444;
        }
        .upgrade-info strong {
            color: #61dafb;
            font-size: 16px;
        }

        .ui-panel {
            width: 220px;
            padding: 15px;
            background-color: #20232a;
            border-radius: 8px;
            border: 1px solid #444;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        .ui-panel h2 { margin-top: 0; color: #61dafb; border-bottom: 1px solid #444; padding-bottom: 10px; }
        .status-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
            font-size: 20px;
            font-weight: bold;
        }
        .status-grid div {
            background-color: #282c34;
            padding: 10px;
            border-radius: 5px;
            text-align: center;
        }
        .status-grid span { display: block; font-size: 24px; }
        .energy-display { color: #FFEB3B; }
        .lives-display { color: #F44336; }
        .wave-display { color: #03A9F4; }
        .score-display { color: #4CAF50; }
        .cell-v2 {
            display: flex; align-items: center; justify-content: center; font-size: 18px; font-weight: bold; color: white; position: relative;
        }
        .cell-v2.buffed {
             box-shadow: 0 0 15px rgba(76, 175, 80, 1), inset 0 0 8px rgba(76, 175, 80, 0.8);
        }

        .tower-range-indicator {
            position: absolute;
            border: 2px dashed rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: none;
            box-sizing: border-box;
            opacity: 0;
            transition: opacity 0.2s;
        }
        .cell-v2:hover .tower-range-indicator {
            opacity: 1;
        }
        .tower-range-indicator.preview {
            opacity: 1;
        }
        .tower-symbol {
            position: relative;
            z-index: 1;
            pointer-events: none;
        }
        .tower-level {
            position: absolute;
            top: 1px;
            right: 3px;
            font-size: 11px;
            font-weight: bold;
            color: #FFEB3B;
            z-index: 3;
            text-shadow: 1px 1px 1px #000;
        }
        .wall-v2 { background-color: #795548; }
        .cannon-v2 { background-color: #FF9800; }
        .missile-v2 { background-color: #673AB7; }
        .laser-v2 { background-color: #E91E63; }
        .buff-v2 { background-color: #009688; }
        .railgun-v2 { background-color: #607D8B; } /* Blue Grey */
        
        .top-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 15px;
        }
        .top-controls button {
            background-color: #61dafb; color: #20232a; border: none; padding: 10px; font-size: 16px; font-weight: bold; border-radius: 5px; cursor: pointer; transition: background-color 0.2s;
        }
        .top-controls button:hover { background-color: #88eaff; }
        .top-controls button:disabled { background-color: #555; color: #888; cursor: not-allowed; }

        .game-controls { margin-top: 15px; }

        .global-actions {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
            position: relative;
        }
        .global-actions button {
            background-color: #4CAF50;
            padding: 8px;
            font-size: 12px;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }
        .global-actions button:disabled {
             background-color: #555; color: #888; cursor: not-allowed; 
        }

        .game-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            display: none;
            justify-content: center;
            align-items: center;
            text-align: center;
            z-index: 300;
            font-size: 14px;
        }
        .game-overlay > div {
            background-color: #282c34;
            padding: 20px 40px;
            border-radius: 8px;
            border: 1px solid #61dafb;
            box-shadow: 0 5px 25px rgba(0,0,0,0.5);
        }
        .game-overlay h2 { font-size: 48px; margin-bottom: 20px; color: #F44336; }
        .game-overlay p { font-size: 16px; line-height: 1.6; }
        .game-overlay .stats-container {
            text-align: left;
            display: inline-block;
            background-color: rgba(0,0,0,0.3);
            padding: 15px;
            border-radius: 8px;
            margin: 15px 0;
            max-width: 300px;
        }
        .game-overlay .stats-container strong {
            color: #61dafb;
            display: block;
            margin-top: 10px;
            font-size: 18px;
            text-align: center;
        }
        .restart-btn {
            background-color: #61dafb; 
            color: #20232a; 
            border: none; 
            padding: 12px 20px; 
            font-size: 18px; 
            font-weight: bold; 
            border-radius: 5px; 
            cursor: pointer; 
            transition: background-color 0.2s;
            margin-top: 20px;
            width: 100%;
        }
        .restart-btn:hover {
            background-color: #88eaff;
        }


        /* Gemini AI Feature Styles */
        .ai-strategy-panel {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #444;
        }
        .ai-strategy-panel button {
            width: 100%;
            background: linear-gradient(45deg, #61dafb, #9c27b0);
            color: white;
            font-weight: bold;
            border: none;
            padding: 10px;
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .ai-strategy-panel button:hover {
            transform: scale(1.05);
        }
        .ai-strategy-panel button:disabled {
            background: #555;
            cursor: not-allowed;
            transform: none;
        }
        #ai-tip-box {
            margin-top: 10px;
            padding: 12px;
            background-color: #282c34;
            border: 1px dashed #61dafb;
            border-radius: 5px;
            font-size: 14px;
            line-height: 1.5;
            min-height: 50px;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #61dafb;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .info-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-top: 10px;
        }
        .info-buttons button {
            background-color: #3a3f4a;
            border: 1px solid #555;
            color: white;
            padding: 8px;
            border-radius: 5px;
            cursor: pointer;
        }
        .info-buttons button:hover {
            background-color: #4a4f5a;
        }
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 300;
        }
        .modal-content {
            background-color: #282c34;
            padding: 20px;
            border-radius: 8px;
            border: 1px solid #61dafb;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            position: relative;
        }
        .modal-close-btn {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            color: white;
            font-size: 24px;
            cursor: pointer;
        }
        #info-modal-body h3 {
            color: #61dafb;
            border-bottom: 1px solid #444;
            padding-bottom: 5px;
        }
        #info-modal-body p {
            margin: 5px 0 15px 0;
            font-size: 14px;
            line-height: 1.6;
        }
        .notification {
            position: fixed;
            top: -100px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(32, 35, 42, 0.9);
            color: #61dafb;
            padding: 15px 25px;
            border-radius: 8px;
            border: 1px solid #61dafb;
            z-index: 1000;
            font-weight: bold;
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s, top 0.5s;
            box-shadow: 0 5px 15px rgba(0,0,0,0.5);
        }
        .notification.show {
            top: 40px;
            opacity: 1;
        }
        #tooltip {
            position: absolute;
            display: none;
            background-color: #20232a;
            color: #fff;
            padding: 10px;
            border-radius: 6px;
            border: 1px solid #61dafb;
            z-index: 400;
            font-size: 12px;
            pointer-events: none;
            text-align: left;
            white-space: pre-wrap;
        }
    </style>
</head>
<body>

    <h1>Maze Craft TD</h1>

    <div class="game-content">
        <div class="version-container">
            <p>íƒ€ì›Œë¥¼ í´ë¦­í•˜ì—¬ ì—…ê·¸ë ˆì´ë“œí•˜ê³ , AIì˜ ì¡°ì–¸ì„ ë°›ì•„ ìµœì ì˜ ë°©ì–´ì„ ì„ êµ¬ì¶•í•˜ì„¸ìš”!</p>
            <div class="game-wrapper-v2">
                <div class="game-container">
                    <div id="game-board-v2" class="game-board">
                        <div id="path-arrows-container"></div>
                    </div>
                </div>
                <div class="ui-panel">
                    <div class="top-controls">
                        <button id="start-wave-btn-v2">Start Wave</button>
                        <button id="game-speed-btn">Speed: 1x</button>
                    </div>

                    <h2>í”Œë ˆì´ì–´ ì •ë³´</h2>
                    <div class="status-grid">
                        <div id="energy-display-v2" class="energy-display">âš¡<span>500</span></div>
                        <div id="lives-display-v2" class="lives-display">â¤ï¸<span>20</span></div>
                        <div id="wave-display-v2" class="wave-display">ğŸŒŠ<span>Wave 0</span></div>
                        <div id="score-display-v2" class="score-display">ğŸ†<span>0</span></div>
                    </div>

                    <h2>ê²Œì„ ì •ë³´</h2>
                    <div class="info-buttons">
                        <button id="tower-info-btn">íƒ€ì›Œ ì •ë³´</button>
                        <button id="monster-info-btn">ëª¬ìŠ¤í„° ì •ë³´</button>
                    </div>
                    
                    <div id="wave-info-panel" style="margin-top: 20px;">
                        <h2>ë‹¤ìŒ ì›¨ì´ë¸Œ ì •ë³´</h2>
                        <div id="wave-info-box" style="font-size: 14px; line-height: 1.6; background-color: #282c34; padding: 10px; border-radius: 5px; min-height: 50px;">
                            <!-- Monster info will be populated by JS -->
                        </div>
                    </div>

                    <div class="game-controls">
                         <div class="global-actions">
                            <button id="repair-all-btn">ì „ì²´ ìˆ˜ë¦¬</button>
                            <button id="upgrade-all-btn">ì „ì²´ ì—…ê·¸ë ˆì´ë“œ</button>
                        </div>
                    </div>

                    <div class="ai-strategy-panel">
                        <h2>AI ì „ëµ ì–´ë“œë°”ì´ì € âœ¨</h2>
                        <button id="get-ai-tip-btn">ì „ëµ íŒ ë°›ê¸°</button>
                        <div id="ai-tip-box">AIê°€ ë‹¹ì‹ ì˜ ë‹¤ìŒ ìˆ˜ë¥¼ ë¶„ì„ ì¤‘ì…ë‹ˆë‹¤...</div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <div id="placement-menu-v2" class="placement-menu">
        <div id="build-options">
            <button data-type="WALL">ë²½ (Blocker)<span>âš¡20</span></button>
            <button data-type="CANNON">ìºë…¼ (Cannon)<span>âš¡100</span></button>
            <button data-type="LASER">ë ˆì´ì € (Laser)<span>âš¡150</span></button>
            <button data-type="MISSILE">ë¯¸ì‚¬ì¼ (Missile)<span>âš¡250</span></button>
            <button data-type="BUFF">ë²„í”„ íƒ€ì›Œ (Buff)<span>âš¡1000</span></button>
            <button data-type="RAILGUN">ë ˆì¼ê±´ (Railgun)<span>âš¡1500</span></button>
        </div>
        <div id="upgrade-options">
            <div id="upgrade-info" class="upgrade-info"></div>
            <button data-type="upgrade">ì—…ê·¸ë ˆì´ë“œ<span></span></button>
            <button data-type="repair">ìˆ˜ë¦¬<span></span></button>
        </div>
        <div id="demolish-option">
            <button data-type="bulldoze">ì² ê±°<span></span></button>
        </div>
    </div>

    <div id="info-modal" class="modal-overlay">
        <div class="modal-content">
            <button id="modal-close-btn" class="modal-close-btn">&times;</button>
            <div id="info-modal-body"></div>
        </div>
    </div>
    
    <div id="tooltip"></div>
    <div id="notification" class="notification"></div>
    <div id="game-overlay-v2" class="game-overlay">
        <div>
            <h2>GAME OVER</h2>
            <p></p>
            <button class="restart-btn" onclick="window.location.reload()">ë‹¤ì‹œ ì‹œì‘</button>
        </div>
    </div>

<script>
(function() {
    // --- ìƒìˆ˜ ì •ì˜ ---
    const GRID_WIDTH = 15, GRID_HEIGHT = 10, CELL_SIZE = 40;
    const START_NODE = { x: 0, y: GRID_HEIGHT - 1 };
    let END_NODE = { x: GRID_WIDTH - 1, y: 0 };
    const TOWER_TYPES = { EMPTY: 0, WALL: 1, CANNON: 2, LASER: 3, MISSILE: 4, BUFF: 5, RAILGUN: 6 };
    const MAX_TOWER_LEVEL = 5;
    const TOWER_COSTS = { 
        [TOWER_TYPES.WALL]: 20, 
        [TOWER_TYPES.CANNON]: 100,
        [TOWER_TYPES.LASER]: 150,
        [TOWER_TYPES.MISSILE]: 250,
        [TOWER_TYPES.BUFF]: 1000,
        [TOWER_TYPES.RAILGUN]: 1500
    };
    const TOWER_STYLES = { 
        [TOWER_TYPES.WALL]: 'wall-v2', 
        [TOWER_TYPES.CANNON]: 'cannon-v2',
        [TOWER_TYPES.LASER]: 'laser-v2',
        [TOWER_TYPES.MISSILE]: 'missile-v2',
        [TOWER_TYPES.BUFF]: 'buff-v2',
        [TOWER_TYPES.RAILGUN]: 'railgun-v2'
    };
    const TOWER_SYMBOLS = { 
        [TOWER_TYPES.WALL]: 'B', 
        [TOWER_TYPES.CANNON]: 'C',
        [TOWER_TYPES.LASER]: 'L',
        [TOWER_TYPES.MISSILE]: 'M',
        [TOWER_TYPES.BUFF]: 'S',
        [TOWER_TYPES.RAILGUN]: 'R'
    };
    const TOWER_SUMMARIES = {
        [TOWER_TYPES.WALL]: "ê²½ë¡œë¥¼ ë§‰ëŠ” íŠ¼íŠ¼í•œ ë°©ì–´ë²½ì…ë‹ˆë‹¤.",
        [TOWER_TYPES.CANNON]: "ê°€ì¥ ê¸°ë³¸ì ì¸ ë‹¨ì¼ ê³µê²©ì„ í•˜ëŠ” ë§ŒëŠ¥í˜• íƒ€ì›Œì…ë‹ˆë‹¤.",
        [TOWER_TYPES.LASER]: "ê³µê²© ì†ë„ê°€ ë§¤ìš° ë¹ ë¥¸ ë‹¨ì¼ ëŒ€ìƒ ê³µê²© íƒ€ì›Œì…ë‹ˆë‹¤.",
        [TOWER_TYPES.MISSILE]: "ê°•ë ¥í•œ ê´‘ì—­ í­ë°œ ê³µê²©ì„ í•˜ëŠ” ë¯¸ì‚¬ì¼ì„ ë°œì‚¬í•©ë‹ˆë‹¤.",
        [TOWER_TYPES.BUFF]: "ì£¼ë³€ íƒ€ì›Œì˜ ê³µê²©ë ¥ì„ ì¦í­ì‹œí‚¤ëŠ” ì§€ì› íƒ€ì›Œì…ë‹ˆë‹¤.",
        [TOWER_TYPES.RAILGUN]: "ì¼ì§ì„  ìƒì˜ ëª¨ë“  ì ì„ ê´€í†µí•˜ëŠ” ê°•ë ¥í•œ ê³µê²©ì„ í•©ë‹ˆë‹¤."
    };
    const TOWER_STATS = {
        [TOWER_TYPES.WALL]: { name: "ë²½", hp: 500, range: 0, damage: 0, attackSpeed: 0, damageUpgrade: 0 },
        [TOWER_TYPES.CANNON]: { name: "ìºë…¼", hp: 250, range: 1.5 * CELL_SIZE, damage: 30, attackSpeed: 1000, damageUpgrade: 15 },
        [TOWER_TYPES.LASER]: { name: "ë ˆì´ì €", hp: 200, range: 1.5 * CELL_SIZE, damage: 15, attackSpeed: 300, damageUpgrade: 5 },
        [TOWER_TYPES.MISSILE]: { name: "ë¯¸ì‚¬ì¼", hp: 300, range: 2.5 * CELL_SIZE, damage: 75, attackSpeed: 2500, aoeRadius: 1.5 * CELL_SIZE, aoeDamage: 60, damageUpgrade: 50 },
        [TOWER_TYPES.BUFF]: { name: "ë²„í”„ íƒ€ì›Œ", hp: 150, range: 2.5 * CELL_SIZE, damage: 0, attackSpeed: 0, damageUpgrade: 0, buffMultiplier: 1.5 },
        [TOWER_TYPES.RAILGUN]: { name: "ë ˆì¼ê±´", hp: 100, range: 4.5 * CELL_SIZE, damage: 300, attackSpeed: 5000, damageUpgrade: 100 }
    };
    const MONSTER_STATS = {
        normal: { name: 'ì¼ë°˜', hp: 75, speed: 50, damage: 20, attackSpeed: 1000, livesCost: 1 },
        elite: { name: 'íŠ¹ìˆ˜', hp: 250, speed: 30, damage: 50, attackSpeed: 900, livesCost: 3, aoeAuraRange: 1.5 * CELL_SIZE, aoeAuraDamage: 10, aoeAuraSpeed: 900 },
        boss: { name: 'ë³´ìŠ¤', hp: 1000, speed: 15, damage: 500, attackSpeed: 1500, livesCost: 999 }
    };
    const MONSTER_STYLES = {
        normal: '',
        elite: 'elite',
        boss: 'boss'
    };
    
    // --- DOM ìš”ì†Œ ---
    const gameBoard = document.getElementById('game-board-v2');
    if (!gameBoard) return;
    const energyDisplay = document.getElementById('energy-display-v2').querySelector('span');
    const livesDisplay = document.getElementById('lives-display-v2').querySelector('span');
    const waveDisplay = document.getElementById('wave-display-v2').querySelector('span');
    const scoreDisplay = document.getElementById('score-display-v2').querySelector('span');
    const waveInfoBox = document.getElementById('wave-info-box');
    const placementMenu = document.getElementById('placement-menu-v2');
    const buildOptions = document.getElementById('build-options');
    const demolishOption = document.getElementById('demolish-option');
    const upgradeOptions = document.getElementById('upgrade-options');
    const upgradeInfo = document.getElementById('upgrade-info');
    const startWaveBtn = document.getElementById('start-wave-btn-v2');
    const repairAllBtn = document.getElementById('repair-all-btn');
    const upgradeAllBtn = document.getElementById('upgrade-all-btn');
    const gameSpeedBtn = document.getElementById('game-speed-btn');
    const gameOverlay = document.getElementById('game-overlay-v2');
    const getAITipBtn = document.getElementById('get-ai-tip-btn');
    const aiTipBox = document.getElementById('ai-tip-box');
    const towerInfoBtn = document.getElementById('tower-info-btn');
    const monsterInfoBtn = document.getElementById('monster-info-btn');
    const infoModal = document.getElementById('info-modal');
    const infoModalBody = document.getElementById('info-modal-body');
    const modalCloseBtn = document.getElementById('modal-close-btn');
    const notificationEl = document.getElementById('notification');
    const tooltipEl = document.getElementById('tooltip');
    const pathArrowsContainer = document.getElementById('path-arrows-container');

    // --- ê²Œì„ ìƒíƒœ ë³€ìˆ˜ ---
    const grid = [], nodes = [], cells = [];
    let towers = [];
    let playerEnergy = 500, playerLives = 20, waveNumber = 0, playerScore = 0, monstersKilled = 0;
    let activeCell = null;
    let monsters = [], projectiles = [];
    let monsterIdCounter = 0;
    let waveInProgress = false;
    let monstersToSpawn = [];
    let lastSpawnTime = 0;
    let lastTimestamp = 0;
    let gameSpeed = 1;
    let notificationTimeout;
    let currentPathForWave = [];
    let totalEnergyEarned = 500;
    let totalRepairSpent = 0;
    let totalUpgradeSpent = 0;
    let totalDamageDealt = 0;

    function init() {
        gameBoard.style.gridTemplateColumns = `repeat(${GRID_WIDTH}, 1fr)`;
        gameBoard.style.width = `${GRID_WIDTH * CELL_SIZE}px`;
        gameBoard.style.height = `${GRID_HEIGHT * CELL_SIZE}px`;

        for (let y = 0; y < GRID_HEIGHT; y++) {
            grid[y] = []; nodes[y] = []; cells[y] = [];
            for (let x = 0; x < GRID_WIDTH; x++) {
                grid[y][x] = TOWER_TYPES.EMPTY;
                const cell = document.createElement('div');
                cell.className = 'cell cell-v2';
                cell.dataset.x = x; cell.dataset.y = y;
                if ((x === START_NODE.x && y === START_NODE.y)) {
                    cell.classList.add('start');
                } else if (x === END_NODE.x && y === END_NODE.y) {
                    cell.classList.add('end');
                }
                
                if (!cell.classList.contains('start') && !cell.classList.contains('end')) {
                    const hpContainer = document.createElement('div');
                    hpContainer.className = 'tower-hp-bar-container';
                    const hpBar = document.createElement('div');
                    hpBar.className = 'tower-hp-bar';
                    hpContainer.appendChild(hpBar);
                    cell.appendChild(hpContainer);
                }
                const rangeIndicator = document.createElement('div');
                rangeIndicator.className = 'tower-range-indicator';
                cell.appendChild(rangeIndicator);
                const towerSymbolSpan = document.createElement('span');
                towerSymbolSpan.className = 'tower-symbol';
                cell.appendChild(towerSymbolSpan);
                const towerLevelSpan = document.createElement('span');
                towerLevelSpan.className = 'tower-level';
                cell.appendChild(towerLevelSpan);
                const cooldownContainer = document.createElement('div');
                cooldownContainer.className = 'cooldown-progress-container';
                const cooldownBar = document.createElement('div');
                cooldownBar.className = 'cooldown-progress-bar';
                cooldownContainer.appendChild(cooldownBar);
                cell.appendChild(cooldownContainer);
                gameBoard.appendChild(cell);
                cells[y][x] = cell;
                nodes[y][x] = { x, y, g:0, h:0, f:0, parent: null };
            }
        }
        
        gameBoard.addEventListener('click', handleCellClick);
        placementMenu.addEventListener('click', handleMenuClick);
        
        buildOptions.querySelectorAll('button').forEach(button => {
            button.addEventListener('mouseenter', showPathAndRangePreview);
            button.addEventListener('mouseleave', hidePathAndRangePreview);
        });

        const demolishButton = demolishOption.querySelector('button');
        demolishButton.addEventListener('mouseenter', showDemolishPreview);
        demolishButton.addEventListener('mouseleave', hidePathAndRangePreview);

        startWaveBtn.addEventListener('click', startWave);
        
        repairAllBtn.addEventListener('click', repairAllTowers);
        repairAllBtn.addEventListener('mouseenter', showRepairTooltip);
        repairAllBtn.addEventListener('mouseleave', hideTooltip);

        upgradeAllBtn.addEventListener('click', upgradeAllTowers);
        upgradeAllBtn.addEventListener('mouseenter', showUpgradeTooltip);
        upgradeAllBtn.addEventListener('mouseleave', hideTooltip);

        gameSpeedBtn.addEventListener('click', toggleGameSpeed);
        getAITipBtn.addEventListener('click', getStrategicTip);
        towerInfoBtn.addEventListener('click', () => showInfoModal('towers'));
        monsterInfoBtn.addEventListener('click', () => showInfoModal('monsters'));
        modalCloseBtn.addEventListener('click', () => infoModal.style.display = 'none');
        infoModal.addEventListener('click', (e) => {
            if (e.target === infoModal) infoModal.style.display = 'none';
        });

        document.addEventListener('click', (e) => {
            if (!placementMenu.contains(e.target) && !e.target.closest('.cell')) {
                placementMenu.style.display = 'none';
                hidePathAndRangePreview();
            }
        });

        updateUI();
        updateWaveInfoUI();
        updateGlobalButtonsState();
        updatePathVisuals();
        requestAnimationFrame(gameLoop);
    }

    function showInfoModal(type) {
        let html = '';
        if (type === 'towers') {
            html += '<h3>íƒ€ì›Œ ì •ë³´</h3>';
            Object.keys(TOWER_TYPES).forEach(key => {
                if (key === 'EMPTY') return;
                
                const towerTypeEnum = TOWER_TYPES[key];
                const stats = TOWER_STATS[towerTypeEnum];
                const cost = TOWER_COSTS[towerTypeEnum];
                const symbol = TOWER_SYMBOLS[towerTypeEnum];
                const summary = TOWER_SUMMARIES[towerTypeEnum];
                
                if (stats) {
                    html += `<h4>${stats.name} (${symbol})</h4>`;
                    if (summary) {
                        html += `<p style="font-style: italic; color: #ccc; margin-top: -10px;">${summary}</p>`;
                    }
                    let desc = `<p>ë¹„ìš©: âš¡${cost || 0} | HP: ${stats.hp}<br>`;
                    if (stats.damage > 0) desc += `ë°ë¯¸ì§€: ${stats.damage}<br>`;
                    if (stats.buffMultiplier > 0) desc += `ë°ë¯¸ì§€ ë²„í”„: x${stats.buffMultiplier}<br>`;
                    if (stats.range > 0) desc += `ì‚¬ê±°ë¦¬: ${stats.range / CELL_SIZE}ì¹¸<br>`;
                    if (stats.attackSpeed > 0) desc += `ê³µê²© ì†ë„: ${stats.attackSpeed / 1000}ì´ˆ<br>`;
                    if (stats.aoeRadius > 0) desc += `ê´‘ì—­ ë°ë¯¸ì§€: ${stats.aoeDamage} (ë°˜ê²½: ${stats.aoeRadius / CELL_SIZE}ì¹¸)<br>`;
                    if (key === 'WALL') desc += `ê²½ë¡œë¥¼ ë§‰ì§€ ì•Šìœ¼ë©°, ëª¬ìŠ¤í„°ëŠ” ë²½ì„ ê³µê²©í•´ì„œ íŒŒê´´í•˜ê³  ì§€ë‚˜ê°‘ë‹ˆë‹¤.<br>`;
                    desc += `</p>`;
                    html += desc;
                }
            });
        } else if (type === 'monsters') {
            html += '<h3>ëª¬ìŠ¤í„° ì •ë³´ (ë‹¤ìŒ ì›¨ì´ë¸Œ ê¸°ì¤€)</h3>';
            const nextWaveNum = waveNumber < 1 ? 1 : waveNumber + 1;
            const hpMultiplier = Math.pow(1.2, nextWaveNum - 1);
            Object.values(MONSTER_STATS).forEach(stats => {
                html += `<h4>${stats.name}</h4>`;
                let infoText = `<p>HP: ${Math.floor(stats.hp * hpMultiplier)}<br>ì´ë™ ì†ë„: ${stats.speed}<br>ê³µê²©ë ¥: ${stats.damage}<br>ê³µê²© ì†ë„: ${stats.attackSpeed/1000}ì´ˆ<br>`;
                if (stats.aoeAuraDamage) {
                    infoText += `ê´‘ì—­ ë°ë¯¸ì§€: ${stats.aoeAuraDamage}<br>`;
                }
                infoText += `ìƒëª…ë ¥ í”¼í•´: ${stats.livesCost}</p>`;
                html += infoText;
            });
        }
        infoModalBody.innerHTML = html;
        infoModal.style.display = 'flex';
    }

    async function getStrategicTip() {
        getAITipBtn.disabled = true;
        aiTipBox.innerHTML = '<div class="loader"></div>';
        let gridRepresentation = '';
        for (let y = 0; y < GRID_HEIGHT; y++) {
            let row = '';
            for (let x = 0; x < GRID_WIDTH; x++) {
                if (x === START_NODE.x && y === START_NODE.y) row += 'S ';
                else if (x === END_NODE.x && y === END_NODE.y) row += 'G ';
                else {
                    const towerType = grid[y][x];
                    if (towerType === TOWER_TYPES.EMPTY) row += 'Â· ';
                    else row += (TOWER_SYMBOLS[towerType] || 'T') + ' ';
                }
            }
            gridRepresentation += row.trim() + '\n';
        }
        const towerList = towers.map(t => `- ${TOWER_SYMBOLS[t.type]} at (${t.x}, ${t.y}) with ${t.hp}/${t.maxHp} HP`).join('\n') || 'None';
        const systemPrompt = `You are an expert strategist for a tower defense game called 'Maze Craft TD'. Your goal is to provide a clear, concise, and actionable tip in Korean to the player based on their current game state. The player is trying to prevent monsters from reaching the Goal (G) from the Start (S). Analyze the map layout, tower positions, and player resources. Monsters will attack and destroy towers if their path is blocked. Provide one helpful tip in 2-3 sentences. Focus on improving tower placement, energy management, creating mazes, or preparing for the next wave. The grid symbols mean: S=Start, G=Goal, Â·=Empty/Path, B=Wall, C=Cannon, L=Laser, M=Missile.`;
        const userQuery = `Current Game State:\n- Grid Size: ${GRID_WIDTH}x${GRID_HEIGHT}\n- Player Energy: ${playerEnergy}\n- Player Lives: ${playerLives}\n- Current Wave: ${waveNumber}\n- Towers:\n${towerList}\n- Map Layout:\n${gridRepresentation}\nPlease provide a strategic tip in Korean.`;
        try {
            const apiKey = "";
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            const payload = {
                contents: [{ parts: [{ text: userQuery }] }],
                systemInstruction: { parts: [{ text: systemPrompt }] },
            };
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            });
            if (!response.ok) throw new Error(`API call failed with status: ${response.status}`);
            const result = await response.json();
            const tip = result.candidates?.[0]?.content?.parts?.[0]?.text;
            aiTipBox.innerText = tip || "íŒì„ ìƒì„±í•˜ëŠ” ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤. ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.";
        } catch (error) {
            console.error("Error fetching AI tip:", error);
            aiTipBox.innerText = "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤. ì ì‹œ í›„ ë‹¤ì‹œ ì‹œë„í•´ ì£¼ì„¸ìš”.";
        } finally {
            getAITipBtn.disabled = false;
        }
    }

    function handleCellClick(e) {
        const cell = e.target.closest('.cell');
        if (!cell || cell.classList.contains('start') || cell.classList.contains('end')) return;

        const x = parseInt(cell.dataset.x), y = parseInt(cell.dataset.y);
        const existingTowerType = grid[y][x];

        if (existingTowerType === TOWER_TYPES.EMPTY && waveInProgress) {
            return;
        }

        activeCell = cell;
        const rect = cell.getBoundingClientRect();
        placementMenu.style.top = `${window.scrollY + rect.bottom}px`;
        placementMenu.style.left = `${window.scrollX + rect.left}px`;
        
        buildOptions.style.display = 'none';
        upgradeOptions.style.display = 'none';
        demolishOption.style.display = 'none';

        if (existingTowerType === TOWER_TYPES.EMPTY) {
            buildOptions.style.display = 'block';
            buildOptions.querySelectorAll('button').forEach(button => {
                const towerType = TOWER_TYPES[button.dataset.type];
                button.disabled = playerEnergy < TOWER_COSTS[towerType] || waveInProgress;
            });
        } else {
            const tower = towers.find(t => t.x === x && t.y === y);
            if (!tower) return; 

            demolishOption.style.display = 'block';
            const refund = Math.floor((TOWER_COSTS[existingTowerType] + tower.totalUpgradeCost) * 0.7);
            demolishOption.querySelector('span').textContent = `+âš¡${refund}`;
            demolishOption.querySelector('button').disabled = waveInProgress;

            upgradeOptions.style.display = 'block';

            const repairBtn = upgradeOptions.querySelector('button[data-type="repair"]');
            
            const lostHpRatio = (tower.maxHp > 0) ? (tower.maxHp - tower.hp) / tower.maxHp : 0;
            const totalInvested = TOWER_COSTS[tower.type] + tower.totalUpgradeCost;
            const repairCost = Math.ceil(totalInvested * lostHpRatio);

            if (repairCost > 0) {
                repairBtn.style.display = 'block';
                repairBtn.disabled = playerEnergy < repairCost || waveInProgress;
                repairBtn.querySelector('span').textContent = `âš¡${repairCost}`;
            } else {
                repairBtn.style.display = 'none';
            }

            const upgradeBtn = upgradeOptions.querySelector('button[data-type="upgrade"]');
            const stats = TOWER_STATS[tower.type];
            let infoText = `<strong>${stats.name} (Lv.${tower.level})</strong><br>HP: ${Math.floor(tower.hp)} / ${tower.maxHp}`;

            if(tower.type !== TOWER_TYPES.WALL) {
                upgradeBtn.style.display = 'block';
                const upgradeCost = Math.floor((TOWER_COSTS[tower.type] + tower.totalUpgradeCost) * 0.5);
                
                const hpIncrease = Math.floor(TOWER_STATS[tower.type].hp * 0.2);
                infoText += ` â†’ ${Math.floor(tower.maxHp + hpIncrease)}`;

                if (stats.damageUpgrade > 0) {
                    const currentEffectiveDamage = getTowerEffectiveDamage(tower);
                    const nextLevelBaseDamage = tower.damage + stats.damageUpgrade;
                    const nextLevelEffectiveDamage = getTowerEffectiveDamage({ ...tower, damage: nextLevelBaseDamage });
                    
                    let damageText;
                    if (currentEffectiveDamage > tower.damage) {
                        damageText = `${tower.damage} <span style="color:#4CAF50;">(+${Math.round(currentEffectiveDamage - tower.damage)})</span>`;
                    } else {
                        damageText = tower.damage;
                    }
                    
                    let nextDamageText;
                    if (nextLevelEffectiveDamage > nextLevelBaseDamage) {
                        nextDamageText = `${nextLevelBaseDamage} <span style="color:#4CAF50;">(+${Math.round(nextLevelEffectiveDamage - nextLevelBaseDamage)})</span>`;
                    } else {
                        nextDamageText = nextLevelBaseDamage;
                    }

                    let upgradeText = `<br>ë°ë¯¸ì§€: ${damageText} â†’ ${nextDamageText}`;
                    if (tower.type === TOWER_TYPES.RAILGUN) {
                         upgradeText += `<br>ê³µê²© ì†ë„: ${(tower.attackSpeed / 1000).toFixed(1)}s â†’ ${( (tower.attackSpeed - 300) / 1000).toFixed(1)}s`;
                    } else if (tower.type === TOWER_TYPES.MISSILE) {
                        upgradeText += `<br>ê³µê²© ì†ë„: ${(tower.attackSpeed / 1000).toFixed(1)}s â†’ ${( (tower.attackSpeed - 100) / 1000).toFixed(1)}s`;
                    }
                    infoText += upgradeText;
                }
                infoText += `<br>ì²˜ì¹˜ ìˆ˜: ${tower.killCount || 0}`;

                const upgradeBtnSpan = upgradeBtn.querySelector('span');

                if (tower.level >= MAX_TOWER_LEVEL) {
                    upgradeBtn.disabled = true;
                    upgradeBtnSpan.textContent = `MAX`;
                } else {
                    upgradeBtn.disabled = playerEnergy < upgradeCost || waveInProgress;
                    upgradeBtnSpan.textContent = `âš¡${upgradeCost}`;
                }
            } else {
                upgradeBtn.style.display = 'none';
                infoText += `<br>ì—…ê·¸ë ˆì´ë“œ ë¶ˆê°€`;
            }
            upgradeInfo.innerHTML = infoText;
        }
        
        placementMenu.style.display = 'block';
    }

    function handleMenuClick(e) {
        if (!activeCell || !e.target.closest('button')) return;
        const x = parseInt(activeCell.dataset.x), y = parseInt(activeCell.dataset.y);
        const action = e.target.closest('button').dataset.type;

        if (action === 'bulldoze') {
            const existingTower = towers.find(t => t.x === x && t.y === y);
            if(existingTower) {
                const refund = Math.floor((TOWER_COSTS[existingTower.type] + existingTower.totalUpgradeCost) * 0.7);
                playerEnergy += refund;
                removeTower(existingTower);
            }
        } else if (action === 'upgrade') {
            const tower = towers.find(t => t.x === x && t.y === y);
            if(tower && tower.level < MAX_TOWER_LEVEL) {
                const upgradeCost = Math.floor((TOWER_COSTS[tower.type] + tower.totalUpgradeCost) * 0.5);
                if(playerEnergy >= upgradeCost) {
                    playerEnergy -= upgradeCost;
                    totalUpgradeSpent += upgradeCost;
                    tower.totalUpgradeCost += upgradeCost;
                    tower.level++;
                    
                    if (TOWER_STATS[tower.type].damageUpgrade > 0) {
                        tower.damage += TOWER_STATS[tower.type].damageUpgrade;
                    }
                    
                    const hpIncrease = Math.floor(TOWER_STATS[tower.type].hp * 0.2);
                    tower.maxHp += hpIncrease;
                    tower.hp += hpIncrease;
                    updateTowerHPBar(tower);

                    if (tower.type === TOWER_TYPES.MISSILE) {
                        tower.aoeDamage += Math.floor(TOWER_STATS[tower.type].aoeDamage * 0.2);
                        tower.attackSpeed -= 100;
                    } else if (tower.type === TOWER_TYPES.RAILGUN) {
                        tower.attackSpeed -= 300;
                    }
                    cells[y][x].querySelector('.tower-level').textContent = `L${tower.level}`;
                }
            }
        } else if (action === 'repair') {
            const tower = towers.find(t => t.x === x && t.y === y);
            if (tower) {
                const lostHpRatio = (tower.maxHp > 0) ? (tower.maxHp - tower.hp) / tower.maxHp : 0;
                const totalInvested = TOWER_COSTS[tower.type] + tower.totalUpgradeCost;
                const repairCost = Math.ceil(totalInvested * lostHpRatio);

                if (playerEnergy >= repairCost) {
                    playerEnergy -= repairCost;
                    totalRepairSpent += repairCost;
                    tower.hp = tower.maxHp;
                    updateTowerHPBar(tower);
                }
            }
        }
        else { // Build tower
            const towerType = TOWER_TYPES[action];
            if (playerEnergy >= TOWER_COSTS[towerType]) {
                playerEnergy -= TOWER_COSTS[towerType];
                addTower(x, y, towerType);
            }
        }
        placementMenu.style.display = 'none';
        updateUI();
        updateGlobalButtonsState();
        updatePathVisuals();
    }

    function addTower(x, y, type) {
        grid[y][x] = type;
        const stats = TOWER_STATS[type];
        const newTower = {
            x, y, type,
            pixelX: x * CELL_SIZE + CELL_SIZE / 2,
            pixelY: y * CELL_SIZE + CELL_SIZE / 2,
            hp: stats.hp, maxHp: stats.hp,
            damage: stats.damage,
            attackSpeed: stats.attackSpeed,
            level: 1,
            totalUpgradeCost: 0,
            cooldown: 0,
            killCount: 0
        };
        if(type === TOWER_TYPES.MISSILE) newTower.aoeDamage = stats.aoeDamage;

        towers.push(newTower);
        
        const cell = cells[y][x];
        cell.classList.add(TOWER_STYLES[type]);
        cell.querySelector('.tower-symbol').textContent = TOWER_SYMBOLS[type];
        if (stats.range > 0) {
            cell.querySelector('.tower-range-indicator').style.width = `${stats.range * 2}px`;
            cell.querySelector('.tower-range-indicator').style.height = `${stats.range * 2}px`;
        }
        if(type !== TOWER_TYPES.WALL) {
            cell.querySelector('.tower-level').textContent = `L1`;
        }
        if (type === TOWER_TYPES.RAILGUN) {
            cell.querySelector('.cooldown-progress-container').style.display = 'block';
        }

        updateTowerHPBar(newTower);
        updateAllBuffs();
        updatePathVisuals();
    }

    function removeTower(tower) {
        const { x, y, type } = tower;
        grid[y][x] = TOWER_TYPES.EMPTY;
        
        const cell = cells[y][x];
        cell.classList.remove(TOWER_STYLES[type]);
        cell.querySelector('.tower-symbol').textContent = '';
        cell.querySelector('.tower-hp-bar-container').style.display = 'none';
        cell.querySelector('.tower-level').textContent = '';
        cell.querySelector('.cooldown-progress-container').style.display = 'none';
        
        towers = towers.filter(t => t !== tower);
        updateAllBuffs();
        updateUI();
        if (!waveInProgress) {
             updatePathVisuals();
        }
    }
    
    function fireProjectile(tower, target) {
        const effectiveDamage = getTowerEffectiveDamage(tower);
        let effectiveAoeDamage = tower.aoeDamage;
        if (getTowerBuffedStatus(tower)) {
             effectiveAoeDamage = (tower.aoeDamage || 0) * TOWER_STATS[TOWER_TYPES.BUFF].buffMultiplier;
        }
        
        const projectile = {
            sourceTower: tower,
            x: tower.pixelX, y: tower.pixelY,
            damage: effectiveDamage, target: target,
            element: document.createElement('div'), towerType: tower.type,
            aoeDamage: effectiveAoeDamage,
        };
        projectile.element.className = `projectile ${tower.type === TOWER_TYPES.MISSILE ? 'missile' : ''}`;
        gameBoard.appendChild(projectile.element);
        projectiles.push(projectile);
    }
    
    function fireLaserBeam(tower, target) {
        damageMonster(target, getTowerEffectiveDamage(tower), tower);
        const beam = document.createElement('div');
        beam.className = 'laser-beam';
        const dx = target.x - tower.pixelX, dy = target.y - tower.pixelY;
        const distance = Math.sqrt(dx * dx + dy * dy);
        const angle = Math.atan2(dy, dx) * (180 / Math.PI);
        beam.style.left = `${tower.pixelX}px`;
        beam.style.top = `${tower.pixelY - 1.5}px`;
        beam.style.width = `${distance}px`;
        beam.style.transform = `rotate(${angle}deg)`;
        gameBoard.appendChild(beam);
        setTimeout(() => beam.remove(), 100);
    }
    
    function fireRailgun(tower, target) {
        const effectiveDamage = getTowerEffectiveDamage(tower);
        const beam = document.createElement('div');
        beam.className = 'railgun-beam';
        const dx = target.x - tower.pixelX;
        const dy = target.y - tower.pixelY;
        const angleRad = Math.atan2(dy, dx);
        const angleDeg = angleRad * (180 / Math.PI);

        beam.style.left = `${tower.pixelX}px`;
        beam.style.top = `${tower.pixelY - 2.5}px`;
        beam.style.width = `${TOWER_STATS[tower.type].range}px`;
        beam.style.transform = `rotate(${angleDeg}deg)`;
        gameBoard.appendChild(beam);
        setTimeout(() => beam.remove(), 200);

        const beamVecX = Math.cos(angleRad);
        const beamVecY = Math.sin(angleRad);
        
        [...monsters].forEach(m => {
            const monsterVecX = m.x - tower.pixelX;
            const monsterVecY = m.y - tower.pixelY;

            const dotProduct = monsterVecX * beamVecX + monsterVecY * beamVecY;

            if (dotProduct > 0 && dotProduct < TOWER_STATS[tower.type].range) {
                const distToLine = Math.abs(monsterVecX * beamVecY - monsterVecY * beamVecX);
                
                if (distToLine < CELL_SIZE / 2) {
                    damageMonster(m, effectiveDamage, tower);
                }
            }
        });
    }

    function updateProjectiles(deltaTime) {
        for (let i = projectiles.length - 1; i >= 0; i--) {
            const p = projectiles[i];
            if (!p.target || p.target.hp <= 0) {
                p.element.remove();
                projectiles.splice(i, 1);
                continue;
            }
            const dx = p.target.x - p.x, dy = p.target.y - p.y;
            const distance = Math.sqrt(dx * dx + dy * dy);
            const speed = (p.towerType === TOWER_TYPES.MISSILE) ? 300 : 400;
            const moveDistance = speed * (deltaTime / 1000);

            if (distance < moveDistance) {
                damageMonster(p.target, p.damage, p.sourceTower);
                if (p.towerType === TOWER_TYPES.MISSILE) {
                    const stats = TOWER_STATS[p.towerType];
                    createExplosion(p.target.x, p.target.y, stats.aoeRadius);
                    monsters.forEach(m => {
                        if (m.hp > 0 && m !== p.target) {
                            const dist = Math.hypot(m.x - p.target.x, m.y - p.target.y);
                            if (dist < stats.aoeRadius) damageMonster(m, p.aoeDamage, p.sourceTower);
                        }
                    });
                }
                p.element.remove();
                projectiles.splice(i, 1);
            } else {
                p.x += (dx / distance) * moveDistance;
                p.y += (dy / distance) * moveDistance;
                p.element.style.left = `${p.x - 5}px`;
                p.element.style.top = `${p.y - 5}px`;
            }
        }
    }

    function createDeathEffect(monster) {
        const particleCount = 8;
        const monsterStyle = MONSTER_STYLES[monster.type];
        let monsterColor = '#9C27B0'; // default normal
        if (monsterStyle === 'elite') monsterColor = '#FF5722';
        if (monsterStyle === 'boss') monsterColor = '#212121';

        for (let i = 0; i < particleCount; i++) {
            const particle = document.createElement('div');
            particle.className = 'monster-particle';
            particle.style.backgroundColor = monsterColor;

            const angle = Math.random() * 2 * Math.PI;
            const distance = Math.random() * 40 + 20;
            const tx = `${Math.cos(angle) * distance}px`;
            const ty = `${Math.sin(angle) * distance}px`;

            particle.style.left = `${monster.x - 4}px`;
            particle.style.top = `${monster.y - 4}px`;
            particle.style.setProperty('--tx', tx);
            particle.style.setProperty('--ty', ty);
            
            gameBoard.appendChild(particle);

            setTimeout(() => {
                particle.remove();
            }, 1000);
        }
    }

    function damageMonster(monster, damage, sourceTower = null) {
        if(monster.hp <= 0) return;
        
        const damageDealt = Math.min(monster.hp, damage);
        totalDamageDealt += damageDealt;
        monster.hp -= damage;

        if (monster.hp <= 0) {
            if (sourceTower) {
                sourceTower.killCount = (sourceTower.killCount || 0) + 1;
            }
            const energyReward = 10 + (waveNumber - 1) * 3;
            playerEnergy += energyReward;
            totalEnergyEarned += energyReward;
            
            const baseScore = monster.type === 'boss' ? 500 : (monster.type === 'elite' ? 20 : 10);
            const scoreMultiplier = Math.pow(1.05, waveNumber - 1);
            playerScore += Math.floor(baseScore * scoreMultiplier);
            monstersKilled++;

            if (monster.type === 'boss') {
                playerLives = Math.min(20, playerLives + 5);
                const bossEnergyBonus = waveNumber * 100;
                playerEnergy += bossEnergyBonus;
                totalEnergyEarned += bossEnergyBonus;
                showNotification(`ë³´ìŠ¤ ì²˜ì¹˜! ìƒëª…ë ¥ 5ì™€ âš¡${bossEnergyBonus} ì—ë„ˆì§€ë¥¼ íšë“í–ˆìŠµë‹ˆë‹¤.`);
            }
            createDeathEffect(monster);
            removeMonsterById(monster.id);
            updateUI();
        } else {
            updateMonsterHPBar(monster);
        }
    }
    
    function getTowerBuffedStatus(tower) {
        if(tower.type === TOWER_TYPES.WALL || tower.type === TOWER_TYPES.BUFF) return false;
        return towers.some(buffTower => 
            buffTower.type === TOWER_TYPES.BUFF &&
            Math.hypot(tower.pixelX - buffTower.pixelX, tower.pixelY - buffTower.pixelY) < TOWER_STATS[TOWER_TYPES.BUFF].range
        );
    }

    function getTowerEffectiveDamage(tower) {
        let damage = tower.damage;
        if (getTowerBuffedStatus(tower)) {
            damage *= TOWER_STATS[TOWER_TYPES.BUFF].buffMultiplier;
        }
        return damage;
    }

    function updateAllBuffs() {
        const buffTowers = towers.filter(t => t.type === TOWER_TYPES.BUFF);
        const buffedCells = new Set();

        if (buffTowers.length > 0) {
            towers.forEach(t => {
                if (t.type === TOWER_TYPES.BUFF || t.type === TOWER_TYPES.WALL) return;
                
                const isBuffed = buffTowers.some(buffTower => 
                    Math.hypot(t.pixelX - buffTower.pixelX, t.pixelY - buffTower.pixelY) < TOWER_STATS[TOWER_TYPES.BUFF].range
                );

                if (isBuffed) {
                    buffedCells.add(cells[t.y][t.x]);
                }
            });
        }
        
        for (let y = 0; y < GRID_HEIGHT; y++) {
            for (let x = 0; x < GRID_WIDTH; x++) {
                const cell = cells[y][x];
                if (buffedCells.has(cell)) {
                    cell.classList.add('buffed');
                } else {
                    cell.classList.remove('buffed');
                }
            }
        }
    }

    function generateWave(waveNum) {
        const hpMultiplier = Math.pow(1.2, waveNum - 1);
        let waveConfig = {};

        if (waveNum > 0 && waveNum % 10 === 0) {
            const bossHpMultiplier = 1 + (waveNum - 10) / 15; // ë³´ìŠ¤ ì²´ë ¥ ìƒìŠ¹ ì™„í™”
            waveConfig = {
                 monsters: [{ type: 'boss', count: 1, hpMultiplier: hpMultiplier * bossHpMultiplier }]
            };
        } else {
            const monsterCount = 10 + Math.floor(Math.pow(waveNum, 1.15));
            waveConfig = {
                monsters: [{ type: 'normal', count: monsterCount, hpMultiplier: hpMultiplier }]
            };

            if (waveNum > 0 && waveNum % 5 === 0) {
                const eliteCount = Math.floor(waveNum / 5);
                waveConfig.monsters.push({ type: 'elite', count: eliteCount, hpMultiplier: hpMultiplier });
            }
        }
        return waveConfig;
    }

    function gameLoop(timestamp) {
        const deltaTime = (timestamp - lastTimestamp) || 0;
        lastTimestamp = timestamp;

        const effectiveDeltaTime = deltaTime * gameSpeed;

        if (playerLives > 0) {
            if (waveInProgress) spawnMonsters(timestamp);
            updateTowers(effectiveDeltaTime);
            updateMonsters(effectiveDeltaTime);
            updateProjectiles(effectiveDeltaTime);
        }
        requestAnimationFrame(gameLoop);
    }
    
    function updateTowers(deltaTime) {
        towers.forEach(tower => {
            if (tower.type === TOWER_TYPES.RAILGUN) {
                const cooldownBar = cells[tower.y][tower.x].querySelector('.cooldown-progress-bar');
                const progress = (tower.attackSpeed - tower.cooldown) / tower.attackSpeed;
                cooldownBar.style.height = `${Math.min(100, progress * 100)}%`;
            }

            if(TOWER_STATS[tower.type].damage === 0) return;
            tower.cooldown -= deltaTime;
            if (tower.cooldown <= 0) {
                const target = findTarget(tower);
                if (target) {
                    if (tower.type === TOWER_TYPES.LASER) fireLaserBeam(tower, target);
                    else if (tower.type === TOWER_TYPES.RAILGUN) fireRailgun(tower, target);
                    else fireProjectile(tower, target);
                    tower.cooldown = tower.attackSpeed;
                }
            }
        });
    }
    
    function createMonster(type, hpMultiplier = 1, path) {
        const stats = MONSTER_STATS[type];
        const monster = {
            id: monsterIdCounter++, type: type, path: path, pathIndex: 1,
            x: START_NODE.x * CELL_SIZE + CELL_SIZE / 2, y: START_NODE.y * CELL_SIZE + CELL_SIZE / 2,
            maxHp: stats.hp * hpMultiplier, hp: stats.hp * hpMultiplier,
            speed: stats.speed, damage: stats.damage, attackSpeed: stats.attackSpeed, attackCooldown: 0,
            livesCost: stats.livesCost,
            element: document.createElement('div'),
            hpBarContainer: document.createElement('div'), hpBar: document.createElement('div'),
        };
        monster.element.className = 'monster';
        if (MONSTER_STYLES[type]) {
            monster.element.classList.add(MONSTER_STYLES[type]);
        }
        if (type === 'elite') {
            monster.aoeAuraCooldown = 0;
            const aura = document.createElement('div');
            aura.className = 'monster-aura';
            aura.style.width = `${stats.aoeAuraRange * 2}px`;
            aura.style.height = `${stats.aoeAuraRange * 2}px`;
            monster.auraElement = aura;
            monster.element.appendChild(aura);
        }
        monster.hpBarContainer.className = 'monster-hp-bar-container';
        monster.hpBar.className = 'monster-hp-bar';
        monster.hpBarContainer.appendChild(monster.hpBar);
        gameBoard.appendChild(monster.element);
        gameBoard.appendChild(monster.hpBarContainer);
        monsters.push(monster);
    }
    
    function updateMonsters(deltaTime) {
        for (let i = monsters.length - 1; i >= 0; i--) {
            const monster = monsters[i];
            if (!monster.path || monster.pathIndex >= monster.path.length) {
                playerLives = Math.max(0, playerLives - monster.livesCost);
                removeMonster(monster, i);
                updateUI();
                if (playerLives <= 0) gameOver();
                continue;
            }

            // Elite monster AOE aura
            if (monster.type === 'elite') {
                monster.aoeAuraCooldown -= deltaTime;
                if(monster.aoeAuraCooldown <= 0) {
                    const stats = MONSTER_STATS.elite;
                    towers.forEach(tower => {
                        const dist = Math.hypot(monster.x - tower.pixelX, monster.y - tower.pixelY);
                        if (dist < stats.aoeAuraRange) {
                            tower.hp -= stats.aoeAuraDamage;
                            updateTowerHPBar(tower);
                            if(tower.hp <= 0) removeTower(tower);
                        }
                    });
                    monster.aoeAuraCooldown = stats.aoeAuraSpeed;
                }
            }

            const nextNode = monster.path[monster.pathIndex];
            const targetTower = towers.find(t => t.x === nextNode.x && t.y === nextNode.y);
            
            if (targetTower) { 
                monster.attackCooldown -= deltaTime;
                if (monster.attackCooldown <= 0) {
                    targetTower.hp -= monster.damage;
                    updateTowerHPBar(targetTower);
                    if (targetTower.hp <= 0) {
                        removeTower(targetTower);
                    }
                    monster.attackCooldown = monster.attackSpeed;
                }
            } else { 
                const targetX = nextNode.x * CELL_SIZE + CELL_SIZE / 2;
                const targetY = nextNode.y * CELL_SIZE + CELL_SIZE / 2;
                const dx = targetX - monster.x, dy = targetY - monster.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                
                const moveDistance = monster.speed * (deltaTime / 1000);

                if (distance < moveDistance) {
                    monster.x = targetX;
                    monster.y = targetY;
                    monster.pathIndex++;
                } else {
                    monster.x += (dx / distance) * moveDistance;
                    monster.y += (dy / distance) * moveDistance;
                }
            }
            
            monster.element.style.left = `${monster.x - monster.element.offsetWidth / 2}px`;
            monster.element.style.top = `${monster.y - monster.element.offsetHeight / 2}px`;
            monster.hpBarContainer.style.left = `${monster.x - monster.hpBarContainer.offsetWidth / 2}px`;
            monster.hpBarContainer.style.top = `${monster.y - monster.element.offsetHeight / 2 - 7}px`;
        }
    }

    function createExplosion(x, y, radius) {
        const explosion = document.createElement('div');
        explosion.className = 'explosion';
        explosion.style.left = `${x - radius}px`;
        explosion.style.top = `${y - radius}px`;
        explosion.style.width = `${radius * 2}px`;
        explosion.style.height = `${radius * 2}px`;
        gameBoard.appendChild(explosion);
        setTimeout(() => explosion.remove(), 300);
    }
    
    function aStar(start, end, canBreakWalls) {
        const openSet = [], closedSet = new Set();
        for (let y = 0; y < GRID_HEIGHT; y++) { for (let x = 0; x < GRID_WIDTH; x++) { nodes[y][x].g=0; nodes[y][x].h=0; nodes[y][x].f=0; nodes[y][x].parent=null; } }
        openSet.push(nodes[start.y][start.x]);
        while (openSet.length > 0) {
            openSet.sort((a,b) => a.f-b.f);
            const currentNode = openSet.shift();
            if (currentNode.x === end.x && currentNode.y === end.y) { const path = []; let temp = currentNode; while (temp) { path.push(temp); temp = temp.parent; } return path.reverse(); }
            closedSet.add(currentNode);
            const neighbors = getNeighbors(currentNode);
            for (const neighbor of neighbors) {
                if (closedSet.has(neighbor)) continue;
                const towerTypeAtNeighbor = grid[neighbor.y][neighbor.x];
                const isObstacle = towerTypeAtNeighbor !== TOWER_TYPES.EMPTY && towerTypeAtNeighbor !== TOWER_TYPES.WALL;

                if (!canBreakWalls && isObstacle) continue;
                
                let cost = 1;
                if (canBreakWalls && towerTypeAtNeighbor !== TOWER_TYPES.EMPTY) {
                    const tower = towers.find(t => t.x === neighbor.x && t.y === neighbor.y);
                    cost += tower ? tower.hp / MONSTER_STATS.normal.damage : 1000;
                }
                const gScore = currentNode.g + cost;
                const inOpenSet = openSet.includes(neighbor);
                if (!inOpenSet || gScore < neighbor.g) {
                    neighbor.g = gScore;
                    neighbor.h = Math.abs(neighbor.x-end.x) + Math.abs(neighbor.y-end.y);
                    neighbor.f = neighbor.g + neighbor.h;
                    neighbor.parent = currentNode;
                    if (!inOpenSet) openSet.push(neighbor);
                }
            }
        }
        return null;
    }

    function updateTowerHPBar(tower) {
        const hpContainer = cells[tower.y][tower.x].querySelector('.tower-hp-bar-container');
        if(hpContainer) {
            hpContainer.style.display = 'block';
            hpContainer.querySelector('.tower-hp-bar').style.width = `${(tower.hp / tower.maxHp) * 100}%`;
        }
    }

    function randomizeEndPoint() {
        const emptyCells = [];
        const restrictedX = 3;
        const restrictedY = GRID_HEIGHT - 4; // ìœ„ë¡œ 3ì¹¸ (y=9, 8, 7, 6)

        for (let y = 0; y < GRID_HEIGHT; y++) {
            for (let x = 0; x < GRID_WIDTH; x++) {
                const isRestricted = x <= restrictedX && y >= restrictedY;
                if (grid[y][x] === TOWER_TYPES.EMPTY && !(x === START_NODE.x && y === START_NODE.y) && !isRestricted) {
                    emptyCells.push({x, y});
                }
            }
        }

        if (emptyCells.length > 0) {
            const oldEndCell = cells[END_NODE.y][END_NODE.x];
            oldEndCell.classList.remove('end');

            const newEndCoords = emptyCells[Math.floor(Math.random() * emptyCells.length)];
            END_NODE.x = newEndCoords.x;
            END_NODE.y = newEndCoords.y;
            
            const newEndCell = cells[END_NODE.y][END_NODE.x];
            newEndCell.classList.add('end');
        }
    }

    function spawnMonsters(timestamp) {
        if (monstersToSpawn.length > 0 && timestamp - lastSpawnTime > (500 / gameSpeed)) {
            const monsterData = monstersToSpawn.shift();
            createMonster(monsterData.type, monsterData.hpMultiplier, monsterData.path);
            lastSpawnTime = timestamp;
        }
        if (monstersToSpawn.length === 0 && monsters.length === 0 && waveInProgress) {
            waveInProgress = false;
            
            if (waveNumber >= 1) {
                randomizeEndPoint();
            }
            updateGlobalButtonsState();
            updateWaveInfoUI();
            updatePathVisuals();
        }
    }

    function updatePathVisuals() {
        gameBoard.querySelectorAll('.path, .path-break').forEach(p => p.classList.remove('path', 'path-break'));
        pathArrowsContainer.innerHTML = '';

        let path = aStar(START_NODE, END_NODE, false);
        let pathIsBreakable = false;
        if (!path) {
            path = aStar(START_NODE, END_NODE, true);
            pathIsBreakable = true;
        }

        if (path) {
            currentPathForWave = path; // Store for wave start
            for (let i = 0; i < path.length - 1; i++) {
                const prevNode = path[i];
                const currNode = path[i+1];
                const cell = cells[prevNode.y][prevNode.x];

                if (!cell.classList.contains('start') && !cell.classList.contains('end')) {
                    if (pathIsBreakable && grid[prevNode.y][prevNode.x] !== TOWER_TYPES.EMPTY) {
                        cell.classList.add('path-break');
                    } else {
                        cell.classList.add('path');
                    }
                }
                
                if (!waveInProgress) {
                    const arrow = document.createElement('div');
                    arrow.className = 'path-arrow';
                    arrow.textContent = 'â€º';

                    const dx = currNode.x - prevNode.x;
                    const dy = currNode.y - prevNode.y;
                    
                    let rotation = 0;
                    if (dx > 0) rotation = 0;      // Right
                    else if (dx < 0) rotation = 180; // Left
                    else if (dy > 0) rotation = 90;  // Down
                    else if (dy < 0) rotation = -90; // Up

                    arrow.style.left = `${prevNode.x * CELL_SIZE + CELL_SIZE / 2}px`;
                    arrow.style.top = `${prevNode.y * CELL_SIZE + CELL_SIZE / 2}px`;
                    arrow.style.setProperty('--translateX', `${dx * CELL_SIZE}px`);
                    arrow.style.setProperty('--translateY', `${dy * CELL_SIZE}px`);
                    arrow.style.setProperty('--rotation', `${rotation}deg`);
                    arrow.style.animationDelay = `${Math.random() * -1.5}s`;
                    pathArrowsContainer.appendChild(arrow);
                }
            }
        }
    }
    
    function showDemolishPreview() {
        if (!activeCell || waveInProgress) return;

        const x = parseInt(activeCell.dataset.x);
        const y = parseInt(activeCell.dataset.y);
        const originalType = grid[y][x];

        if (originalType === TOWER_TYPES.EMPTY) return;

        // --- Path Preview ---
        grid[y][x] = TOWER_TYPES.EMPTY; // Temporarily remove tower
        let path = aStar(START_NODE, END_NODE, false);
        if (!path) {
            path = aStar(START_NODE, END_NODE, true);
        }
        grid[y][x] = originalType; // Restore tower
        
        if (path) {
            path.forEach(node => {
                const cell = cells[node.y][node.x];
                if (!cell.classList.contains('start') && !cell.classList.contains('end')) {
                    cell.classList.add('path-preview');
                }
            });
        }
    }

    function showPathAndRangePreview(e) {
        if (!activeCell || waveInProgress) return;

        const x = parseInt(activeCell.dataset.x);
        const y = parseInt(activeCell.dataset.y);

        if (grid[y][x] !== TOWER_TYPES.EMPTY) return;
        
        const towerType = TOWER_TYPES[e.target.dataset.type];
        if (!towerType) return;

        // --- Range Preview ---
        const stats = TOWER_STATS[towerType];
        if (stats.range > 0) {
            const rangeIndicator = activeCell.querySelector('.tower-range-indicator');
            rangeIndicator.style.width = `${stats.range * 2}px`;
            rangeIndicator.style.height = `${stats.range * 2}px`;
            rangeIndicator.classList.add('preview');
        }

        // --- Path Preview ---
        grid[y][x] = towerType;
        let path = aStar(START_NODE, END_NODE, false);
        if (!path) {
            path = aStar(START_NODE, END_NODE, true);
        }
        grid[y][x] = TOWER_TYPES.EMPTY;
        
        if (path) {
            path.forEach(node => {
                const cell = cells[node.y][node.x];
                if (!cell.classList.contains('start') && !cell.classList.contains('end')) {
                    cell.classList.add('path-preview');
                }
            });
        }
    }

    function hidePathAndRangePreview() {
        if (!activeCell) return;
        
        const rangeIndicator = activeCell.querySelector('.tower-range-indicator');
        if (rangeIndicator) {
             rangeIndicator.classList.remove('preview');
        }

        gameBoard.querySelectorAll('.path-preview').forEach(cell => {
            cell.classList.remove('path-preview');
        });
    }


    function updateUI() {
        energyDisplay.innerText = playerEnergy;
        livesDisplay.innerText = playerLives;
        waveDisplay.innerText = `Wave ${waveNumber}`;
        scoreDisplay.innerText = playerScore;
    }

    function updateWaveInfoUI() {
        const nextWave = generateWave(waveNumber + 1);
        let infoHtml = '';
        nextWave.monsters.forEach(group => {
            const monsterInfo = MONSTER_STATS[group.type];
            const hp = Math.floor(monsterInfo.hp * (group.hpMultiplier || 1));
            infoHtml += `<div>- ${monsterInfo.name} x${group.count} (HP: ${hp})</div>`;
        });
        waveInfoBox.innerHTML = infoHtml;
    }

    function findTarget(tower) {
        let closestMonster = null;
        let minDistance = TOWER_STATS[tower.type].range;
        monsters.forEach(monster => {
            const dist = Math.hypot(tower.pixelX - monster.x, tower.pixelY - monster.y);
            if (dist < minDistance) {
                minDistance = dist;
                closestMonster = monster;
            }
        });
        return closestMonster;
    }

    function startWave() {
        if (waveInProgress) return;
        waveInProgress = true;
        updateGlobalButtonsState();
        waveNumber++;
        updateUI();
        waveInfoBox.innerHTML = 'ì›¨ì´ë¸Œ ì§„í–‰ ì¤‘...';
        updatePathVisuals(); // Hides arrows
        const currentWave = generateWave(waveNumber);
        
        monstersToSpawn = [];
        currentWave.monsters.forEach(monsterGroup => {
            for (let i = 0; i < monsterGroup.count; i++) {
                monstersToSpawn.push({ 
                    type: monsterGroup.type, 
                    hpMultiplier: monsterGroup.hpMultiplier || 1,
                    path: currentPathForWave // Use the path calculated at wave start
                });
            }
        });

        if (waveNumber > 0 && waveNumber % 5 === 0) {
            for (let i = monstersToSpawn.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [monstersToSpawn[i], monstersToSpawn[j]] = [monstersToSpawn[j], monstersToSpawn[i]];
            }
        }
    }

    function repairAllTowers() {
        if (waveInProgress) return;
        
        let totalCost = 0;
        let repairedCount = 0;

        const towersToRepair = towers
            .filter(t => t.hp < t.maxHp)
            .map(t => {
                const lostHpRatio = (t.maxHp > 0) ? (t.maxHp - t.hp) / t.maxHp : 0;
                const totalInvested = TOWER_COSTS[t.type] + t.totalUpgradeCost;
                return {
                    tower: t,
                    cost: Math.ceil(totalInvested * lostHpRatio)
                };
            })
            .sort((a, b) => a.cost - b.cost);

        if (towersToRepair.length === 0) {
            updateGlobalButtonsState();
            return;
        }
    
        for (const item of towersToRepair) {
            if (playerEnergy >= item.cost) {
                playerEnergy -= item.cost;
                totalRepairSpent += item.cost;
                item.tower.hp = item.tower.maxHp;
                updateTowerHPBar(item.tower);
                totalCost += item.cost;
                repairedCount++;
            } else {
                break;
            }
        }
    
        if (repairedCount > 0) {
            updateUI();
            showNotification(`âš¡${totalCost}ë¥¼ ì†Œëª¨í•˜ì—¬ ${repairedCount}ê°œì˜ íƒ€ì›Œë¥¼ ìˆ˜ë¦¬í–ˆìŠµë‹ˆë‹¤.`);
        } else {
            showNotification(`ì—ë„ˆì§€ê°€ ë¶€ì¡±í•˜ì—¬ íƒ€ì›Œë¥¼ ìˆ˜ë¦¬í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
        }
        
        updateGlobalButtonsState();
    }

    function upgradeAllTowers() {
        if (waveInProgress) return;
        
        const upgradableTowers = towers
            .filter(t => t.level < MAX_TOWER_LEVEL && t.type !== TOWER_TYPES.WALL)
            .map(t => ({
                tower: t,
                cost: Math.floor((TOWER_COSTS[t.type] + t.totalUpgradeCost) * 0.5)
            }))
            .sort((a, b) => a.cost - b.cost);
        
        let totalCost = 0;
        const upgradedCounts = {};

        for(const item of upgradableTowers) {
            if (playerEnergy >= item.cost) {
                const tower = item.tower;
                playerEnergy -= item.cost;
                totalUpgradeSpent += item.cost;
                totalCost += item.cost;
                tower.totalUpgradeCost += item.cost;
                tower.level++;
                
                if (TOWER_STATS[tower.type].damageUpgrade > 0) {
                    tower.damage += TOWER_STATS[tower.type].damageUpgrade;
                }
                
                const hpIncrease = Math.floor(TOWER_STATS[tower.type].hp * 0.2);
                tower.maxHp += hpIncrease;
                tower.hp += hpIncrease;
                updateTowerHPBar(tower);

                if (tower.type === TOWER_TYPES.MISSILE) {
                    tower.aoeDamage += Math.floor(TOWER_STATS[tower.type].aoeDamage * 0.2);
                    tower.attackSpeed -= 100;
                } else if (tower.type === TOWER_TYPES.RAILGUN) {
                    tower.attackSpeed -= 300;
                }
                cells[tower.y][tower.x].querySelector('.tower-level').textContent = `L${tower.level}`;
                
                const towerName = TOWER_STATS[tower.type].name;
                upgradedCounts[towerName] = (upgradedCounts[towerName] || 0) + 1;
            } else {
                break; 
            }
        }
        if (totalCost > 0) {
            let summary = `âš¡${totalCost}ë¥¼ ì†Œëª¨í•˜ì—¬ ì—…ê·¸ë ˆì´ë“œ ì™„ë£Œ!<br>`;
            let totalUpgraded = 0;
            for(const name in upgradedCounts) {
                summary += `${name} ${upgradedCounts[name]}ê°œ, `;
                totalUpgraded += upgradedCounts[name];
            }
            summary = summary.slice(0, -2);
            showNotification(summary);
        }
        updateUI();
        updateGlobalButtonsState();
    }

    function toggleGameSpeed() {
        gameSpeed = gameSpeed === 1 ? 2 : 1;
        gameSpeedBtn.textContent = `Speed: ${gameSpeed}x`;
    }
    
    function updateGlobalButtonsState() {
        if (waveInProgress) {
            startWaveBtn.disabled = true;
            getAITipBtn.disabled = true;
            repairAllBtn.disabled = true;
            upgradeAllBtn.disabled = true;
            return;
        }
        startWaveBtn.disabled = false;
        getAITipBtn.disabled = false;

        const canRepair = towers.some(t => t.hp < t.maxHp);
        repairAllBtn.disabled = !canRepair;

        const canUpgrade = towers.some(t => t.level < MAX_TOWER_LEVEL && t.type !== TOWER_TYPES.WALL);
        upgradeAllBtn.disabled = !canUpgrade;
    }

    function showNotification(message) {
        clearTimeout(notificationTimeout);
        notificationEl.innerHTML = message;
        notificationEl.classList.add('show');
        notificationTimeout = setTimeout(() => {
            notificationEl.classList.remove('show');
        }, 3000);
    }

    function showRepairTooltip(event) {
        let totalRepairCost = 0;
        towers.forEach(t => {
            if (t.hp < t.maxHp) {
                const lostHpRatio = (t.maxHp > 0) ? (t.maxHp - t.hp) / t.maxHp : 0;
                const totalInvested = TOWER_COSTS[t.type] + t.totalUpgradeCost;
                totalRepairCost += Math.ceil(totalInvested * lostHpRatio);
            }
        });
        tooltipEl.innerHTML = `ì˜ˆìƒ ë¹„ìš©: âš¡${totalRepairCost}`;
        tooltipEl.style.display = 'block';
        tooltipEl.style.left = `${event.pageX + 15}px`;
        tooltipEl.style.top = `${event.pageY + 15}px`;
    }

    function showUpgradeTooltip(event) {
        const upgradableTowers = towers
            .filter(t => t.level < MAX_TOWER_LEVEL && t.type !== TOWER_TYPES.WALL)
            .map(t => ({
                cost: Math.floor((TOWER_COSTS[t.type] + t.totalUpgradeCost) * 0.5),
                name: TOWER_STATS[t.type].name
            }));
        
        let totalCost = 0;
        const upgradeCounts = {};
        upgradableTowers.forEach(item => {
            totalCost += item.cost;
            upgradeCounts[item.name] = (upgradeCounts[item.name] || 0) + 1;
        });

        let summary = `ì˜ˆìƒ ë¹„ìš©: âš¡${totalCost}<br>`;
        if (Object.keys(upgradeCounts).length > 0) {
            for (const name in upgradeCounts) {
                summary += `${name} ${upgradeCounts[name]}ê°œ, `;
            }
            summary = summary.slice(0, -2);
        } else {
            summary += "ì—…ê·¸ë ˆì´ë“œ ëŒ€ìƒ ì—†ìŒ";
        }

        tooltipEl.innerHTML = summary;
        tooltipEl.style.display = 'block';
        tooltipEl.style.left = `${event.pageX + 15}px`;
        tooltipEl.style.top = `${event.pageY + 15}px`;
    }

    function hideTooltip() {
        tooltipEl.style.display = 'none';
    }


    function removeMonster(monster, index) {
        monster.element.remove();
        monster.hpBarContainer.remove();
        monsters.splice(index, 1);
    }

    function removeMonsterById(id) {
        const index = monsters.findIndex(m => m.id === id);
        if (index !== -1) removeMonster(monsters[index], index);
    }

    function updateMonsterHPBar(monster) {
        monster.hpBar.style.width = `${(monster.hp / monster.maxHp) * 100}%`;
    }

    function getNeighbors(node) {
        const res = []; const {x, y} = node;
        if (x > 0) res.push(nodes[y][x-1]); if (x < GRID_WIDTH-1) res.push(nodes[y][x+1]);
        if (y > 0) res.push(nodes[y-1][x]); if (y < GRID_HEIGHT-1) res.push(nodes[y+1][x]);
        return res;
    }
    
    function gameOver() {
        const towerCounts = towers.reduce((acc, tower) => {
            const name = TOWER_STATS[tower.type].name;
            acc[name] = (acc[name] || 0) + 1;
            return acc;
        }, {});

        const towerCountString = Object.entries(towerCounts)
            .map(([name, count]) => `${name}: ${count}ê°œ`)
            .join('<br>');

        const gameOverContent = gameOverlay.querySelector('div');
        gameOverContent.innerHTML = `
            <h2>GAME OVER</h2>
            <p>
                ìµœì¢… ì›¨ì´ë¸Œ: ${waveNumber}<br>
                ìµœì¢… ì ìˆ˜: ${playerScore}<br>
                ì²˜ì¹˜í•œ ëª¬ìŠ¤í„°: ${monstersKilled}
            </p>
            <div class="stats-container">
                <strong>--- ìƒì„¸ ì •ë³´ ---</strong>
                íšë“í•œ ì´ ì—ë„ˆì§€: âš¡${totalEnergyEarned}<br>
                ì´ ì—…ê·¸ë ˆì´ë“œ ë¹„ìš©: âš¡${totalUpgradeSpent}<br>
                ì´ ìˆ˜ë¦¬ ë¹„ìš©: âš¡${totalRepairSpent}<br>
                ì´ ëˆ„ì  ë°ë¯¸ì§€: ${Math.floor(totalDamageDealt)}<br>
                <strong>--- ê±´ì„¤ëœ íƒ€ì›Œ ---</strong>
                ${towerCountString || "ì—†ìŒ"}
            </div>
            <button class="restart-btn" onclick="window.location.reload()">ë‹¤ì‹œ ì‹œì‘</button>
        `;
        gameOverlay.style.display = 'flex';
    }

    init();
})();
</script>
</body>
</html>
